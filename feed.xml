<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>苏苏</title>
    <link href="" rel="self" />
    <link href="http://sukai.me/" />
    <updated>2016-04-19T16:30:00Z</updated>
    <id>http://sukai.me/</id>
    
    <entry>
        <title><![CDATA[Python中的排序总结]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/sorting-in-python/"/>
        <updated>2016-04-19T16:30:00Z</updated>
        <published>2016-04-19T16:30:00Z</published>
        <id>http://sukai.me/sorting-in-python/</id>
        <content type="html">
            <![CDATA[
             <p>笔者阅读外文博客，整理了Python中List, Tuple, Dictionary三类常见数据结构的相关排序的tips  </p>

<h2>一. 对List（或Tuple）进行排序</h2>

<h3>1.1 最简单的List排序</h3>

<p>假设我们有一组数字列表：<code>a = [3,6,8,2,78,1,23,45,9]</code>  </p>

<p>我们可以通过<code>sort</code>方法和<code>sorted</code>方法对a进行排序。两者的区别在于：<code>sort</code>是list自带的方法，它会将原先的list直接修改为排序完成后的list；<code>sorted</code>方法不会修改原先的list，而是返回一个新的排序后的list  </p>

<pre><code>&gt;&gt;&gt; sorted(a)  
[1, 2, 3, 6, 8, 9, 23, 45, 78]  
&gt;&gt;&gt;  
&gt;&gt;&gt; a.sort()  
&gt;&gt;&gt; a  
[1, 2, 3, 6, 8, 9, 23, 45, 78]</code></pre>

<p>如果要求逆序，可以：  </p>

<pre><code>&gt;&gt;&gt; sorted(a, reverse=True)  
&gt;&gt;&gt;  
&gt;&gt;&gt; a.sort(reverse=True)</code></pre>

<p><code>sort</code>和<code>sorted</code>执行时都会调用每个对象的<code>__cmp__</code>方法，该方法用于比较相关值，以便决定排序的结果  </p>

<h3>1.2 最简单的Tuple排序</h3>

<p>tuple排序和list类似，只不过python的tuple是不可变对象，所以只能用<code>sorted</code>了  </p>

<pre><code>&gt;&gt;&gt; tup = (3, 6, 8, 2, 78, 1, 23, 45, 9)  
&gt;&gt;&gt; sorted(tup)  
[1, 2, 3, 6, 8, 9, 23, 45, 78]</code></pre>

<h3>1.3 对一组列表或者元组进行排序</h3>

<p>首先我们需要确定：依据每个元素（该元素是list或者tuple）中的第几个元素进行排序呢？  </p>

<p>只需要给<code>sorted</code>或者<code>sort</code>传入key参数指定排序依据的key即可  </p>

<pre><code>&gt;&gt;&gt; def getKey(item):  
...     return item[0]  
&gt;&gt;&gt; l = [[2, 3], [6, 7], [3, 34], [24, 64], [1, 43]]  
&gt;&gt;&gt; sorted(l, key=getKey)  
[[1, 43], [2, 3], [3, 34], [6, 7], [24, 64]]</code></pre>

<p>同样的，依据第二个元素排序  </p>

<pre><code>def getKey(item):  
    return item[1]</code></pre>

<p>一组tuple的排序同上  </p>

<pre><code>&gt;&gt;&gt; a = [(2, 3), (6, 7), (3, 34), (24, 64), (1, 43)]  
&gt;&gt;&gt; sorted(l, key=getKey)  
[(1, 43), (2, 3), (3, 34), (6, 7), (24, 64)]</code></pre>

<h3>1.4 对一组自定义对象进行排序</h3>

<pre><code>class Custom(object):  
    def __init__(self, name, number):  
        self.name = name  
        self.number = number  

    def __repr__(self):  
        return &#39;{}: {} {}&#39;.format(self.__class__.__name__,  
                                  self.name,  
                                  self.number)  

customlist = [  
    Custom(&#39;object&#39;, 99),  
    Custom(&#39;michael&#39;, 1),  
    Custom(&#39;theodore the great&#39;, 59),  
    Custom(&#39;life&#39;, 42)  
]</code></pre>

<p>依据number对customlist进行排序  </p>

<pre><code>def getKey(custom):  
    return custom.number  

&gt;&gt;&gt; sorted(customlist, key=getKey)  
[Custom: michael 1, Custom: life 42,  
Custom: theodore the great 59, Custom: object 99]</code></pre>

<p>我们也可以不使用key参数，使用<code>__cmp__</code>  </p>

<pre><code>class Custom(object):  
    def __init__(self, name, number):  
        self.name = name  
        self.number = number  

    def __repr__(self):  
        return &#39;{}: {} {}&#39;.format(self.__class__.__name__,  
                                  self.name,  
                                  self.number)  

    def __cmp__(self, other):  
        if hasattr(other, &#39;number&#39;):  
            return self.number.__cmp__(other.number)</code></pre>

<pre><code>&gt;&gt;&gt; sorted(customlist)  
[Custom: michael 1, Custom: life 42, Custom: theodore the great 59, Custom: object 99]</code></pre>

<h3>1.5 对一组由不同对象组成的list进行排序</h3>

<pre><code>class AnotherObject(object):  
    def __init__(self, tag, age, rate):  
        self.tag = tag  
        self.age = age  
        self.rate = rate  

    def __repr__(self):  
        return &#39;{}: {} {} {}&#39;.format(self.__class__.__name__,  
                                     self.tag,  
                                     self.age, self.rate)  

    def __cmp__(self, other):  
        if hasattr(other, &#39;age&#39;):  
            return self.age.__cmp__(other.age)</code></pre>

<pre><code>customlist = [  
    Custom(&#39;object&#39;, 99),  
    Custom(&#39;michael&#39;, 1),  
    Custom(&#39;theodore the great&#39;, 59),  
    Custom(&#39;life&#39;, 42),  
    AnotherObject(&#39;bananas&#39;, 37, 2.2),  
    AnotherObject(&#39;pants&#39;, 73, 5.6),  
    AnotherObject(&#39;lemur&#39;, 44, 9.2)  
]</code></pre>

<pre><code>&gt;&gt;&gt; sorted(customlist)  
Traceback (most recent call last):  
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  
TypeError: an integer is required</code></pre>

<p>这时候我们会得到一个错误。因为Custom并没有age属性，AnotherObject并没有number属性。我们只需要重新定义我们的两个类即可  </p>

<pre><code>class Custom(object):  
    def __init__(self,name,number):  
        self.name = name  
        self.number = number  

    def __repr__(self):  
        return &#39;{}: {} {}&#39;.format(self.__class__.__name__,  
                                  self.name,  
                                  self.number)  

    def __cmp__(self, other):  
        if hasattr(other, &#39;getKey&#39;):  
            return self.getKey().__cmp__(other.getKey())  

    def getKey(self):  
        return self.number  


class AnotherObject(object):  
    def __init__(self, tag, age, rate):  
        self.tag = tag  
        self.age = age  
        self.rate = rate  

    def __repr__(self):  
        return &#39;{}: {} {} {}&#39;.format(self.__class__.__name__,  
                                     self.tag,  
                                     self.age, self.rate)  

    def __cmp__(self, other):  
        if hasattr(other, &#39;getKey&#39;):  
            return self.getKey().__cmp__(other.getKey())  

    def getKey(self):  
        return self.age</code></pre>

<pre><code>&gt;&gt;&gt; sorted(customlist)  
[Custom: michael 1, AnotherObject: bananas 37 2.2,  
Custom: life 42, AnotherObject: lemur 44 9.2,  
Custom: theodore the great 59, AnotherObject: pants 73 5.6,  
Custom: object 99]</code></pre>

<p>我们也可以使用key参数完成  </p>

<pre><code>def getKey(customobj):  
    return customobj.getKey()</code></pre>

<pre><code>&gt;&gt;&gt; sorted(customlist, key=getKey)  
[Custom: michael 1, AnotherObject: bananas 37 2.2,  
Custom: life 42, AnotherObject: lemur 44 9.2,  
Custom: theodore the great 59, AnotherObject: pants 73 5.6,  
Custom: object 99]</code></pre>

<h2>二. 对Dictionary进行排序</h2>

<p>需要注意的是：我们无法对一个dict进行真正的排序，因为dict是内置无序的，我们所说的排序是返回一个排序完成后的表示，本质是一个list或者一组tuple等等  </p>

<p>假设我们有dict如下：<code>numbers = {&#39;first&#39;: 1, &#39;second&#39;: 2, &#39;third&#39;: 3, &#39;Fourth&#39;: 4}  
</code>  </p>

<h3>2.1 根据keys对dict进行排序</h3>

<p>如果我们需要根据dict的keys进行排序，最简单的方式就是使用内建方法<code>sorted</code>（dict没有sort方法），它会返回一组排序好的keys list。  </p>

<pre><code>&gt;&gt;&gt; sorted(numbers)  
[&#39;fourth&#39;, &#39;first&#39;, &#39;second&#39;, &#39;third&#39;]</code></pre>

<h3>2.2 根据values对dict进行排序</h3>

<p>依然可以使用<code>sorted</code>解决  </p>

<pre><code>&gt;&gt;&gt; sorted(numbers.value())  
[1,2,3,4]</code></pre>

<h3>2.3 自定义dict排序：通过keys（values）来对values（keys）排序，并只返回values（keys）</h3>

<p>通过values对keys排序  </p>

<pre><code># Use the __getitem__ method as the key function  
&gt;&gt;&gt; sorted(numbers, key=numbers.__getitem__)  
# In order of sorted values: [1, 2, 3, 4]  
[&#39;first&#39;, &#39;second&#39;, &#39;third&#39;, &#39;Fourth&#39;]</code></pre>

<p>通过keys来对values排序  </p>

<pre><code># Uses the first element of each tuple to compare  
&gt;&gt;&gt; [value for (key, value) in sorted(numbers.items())]  
[4, 1, 2, 3]  
# In order of sorted keys: [&#39;Fourth&#39;, &#39;first&#39;, &#39;second&#39;, &#39;third&#39;]</code></pre>

<p>逆序  </p>

<pre><code>&gt;&gt;&gt; sorted(numbers, key=numbers.__getitem__, reverse=True)  
[&#39;Fourth&#39;, &#39;third&#39;, &#39;second&#39;, &#39;first&#39;]  
&gt;&gt;&gt; [value for (key, value) in sorted(numbers.items(), reverse=True)]  
[3, 2, 1, 4]</code></pre>

<h3>2.4</h3>

<pre><code># Won&#39;t change the items to be returned, only while sorting  
&gt;&gt;&gt; sorted(numbers, key=str.lower)  
[&#39;first&#39;, &#39;Fourth&#39;, &#39;second&#39;, &#39;third&#39;]</code></pre>

<pre><code>&gt;&gt;&gt; month = dict(one=&#39;January&#39;,  
                 two=&#39;February&#39;,  
                 three=&#39;March&#39;,  
                 four=&#39;April&#39;,  
                 five=&#39;May&#39;)</code></pre>

<pre><code>&gt;&gt;&gt; numbermap = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4, &#39;five&#39;: 5}  
&gt;&gt;&gt; sorted(month, key=numbermap.__getitem__)  
[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39;]</code></pre>

<p>如果我想根据字符串中重复字母出现的次数进行排序：  </p>

<pre><code>def repeats(string):  
    # Lower the case in the string  
    string = string.lower()  

    # Get a set of the unique letters  
    uniques = set(string)  

    # Count the max occurrences of each unique letter  
    counts = [string.count(letter) for letter in uniques]  
    return max(counts)</code></pre>

<pre><code># From greatest to least repeats  
&gt;&gt;&gt; sorted(month.values(), key=repeats, reverse=True)  
[&#39;February&#39;, &#39;January&#39;, &#39;March&#39;, &#39;April&#39;, &#39;May&#39;]</code></pre>

<h3>2.5 一些更高级的排序功能</h3>

<pre><code>trans = dict(January=33, February=30, March=24, April=0, May=7)</code></pre>

<p>对value提出某种特定要求的排序：偶数比奇数优先  </p>

<pre><code>def evens1st(num):  
    # Test with modulus (%) two  
    if num == 0:  
        return -2  
    # It&#39;s an even number, return the value  
    elif num % 2 == 0:  
        return num  
    # It&#39;s odd, return the negated inverse  
    else:  
        return -1 * (num ** -1)</code></pre>

<pre><code>&gt;&gt;&gt; sorted(trans.values(), key=evens1st, reverse=True)  
[30, 24, 33, 7, 0]</code></pre>

<h3>2.6 根据key和value排序，并返回排序之后的（key, value）组合</h3>

<pre><code>import operator  
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}  
sorted_x = sorted(x.items(), key=operator.itemgetter(1))</code></pre>

<pre><code>import operator  
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}  
sorted_x = sorted(x.items(), key=operator.itemgetter(0)</code></pre>

<hr/>

<p>本文翻译自：  </p>

<ul>
<li><a href="http://pythoncentral.io/how-to-sort-a-list-tuple-or-object-with-sorted-in-python/" target="_blank">pythoncentral-sort-list-tuple</a><br/></li>
<li><a href="http://pythoncentral.io/how-to-sort-python-dictionaries-by-key-or-value/" target="_blank">pythoncental-sort-dictionary</a></li>
</ul>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[GIL:Python多线程模型的核心]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/python-multi-thread-model/"/>
        <updated>2016-03-27T20:30:00Z</updated>
        <published>2016-03-27T20:30:00Z</published>
        <id>http://sukai.me/python-multi-thread-model/</id>
        <content type="html">
            <![CDATA[
             <h3>前言</h3>

<p>很久之前就时常听说Python GIL问题，有关这方面的资料一直没有认真整理下来，比较容易遗忘。最近在网上瞄到GIL相关字眼，既然GIL是python多线程模型的核心，那么不如趁此机会好好总结一次（内容非原创分析，主要参考《Python源码分析》一书）  </p>

<p>首先，GIL是什么，不多说。<a href="http://cenalulu.github.io/python/gil-in-python/" title="gil-in-python" target="_blank">Python的GIL是什么鬼，多线程性能究竟如何</a>  </p>

<p>总而言之，在python中，同一时间只有一个线程能访问Python C API，能执行机器码  </p>

<p>如何绕过GIL，或者说如何提高Python多核的利用效率，也有很多些文章总结得很好了，请读者移步。<a href="http://zhuoqiang.me/python-thread-gil-and-ctypes.html" target="_blank">python 线程，GIL 和 ctypes</a>  </p>

<p>下面将围绕线程的创建，调度，状态保护机制等方面，并结合GIL谈谈对python多线程模型的认识  </p>

<h3>Python中线程的调度机制</h3>

<p>线程的调度机制主要解决两方面问题：  </p>

<ul>
<li>1.何时挂起当前线程，选择下一个处于等待状态的线程？<br/></li>
<li>2.选择激活哪一个等待状态中的线程？<br/></li>
</ul>

<p>问题1，即线程的调度问题，python中主要采用标准调度和阻塞调度两种方式  </p>

<h4>标准调度</h4>

<p>Python通过软件模拟时钟中断来激活调度。时钟中断是指：每个线程执行到第N条指令时，将释放GIL，引起线程调度  </p>

<p>N可以通过<code>sys.getcheckintercal()</code>获取  </p>

<h4>阻塞调度</h4>

<p>若当前线程通过等待输入，睡眠等方法将自身阻塞，那么python就将等待GIL的其余线程唤醒，进行一次调度  </p>

<p>阻塞调度是不会重置前一个执行线程的指令执行计数的  </p>

<p>那么对于问题2，python是直接将调度权利交由操作系统，由操作系统的线程调度机制决定，至于选择谁，天知道呢  </p>

<p>也由此可以看出，Python的线程调度和os的线程调度的粘合关键就是GIL  </p>

<h3>Python线程的创建</h3>

<p>当用户创建线程时，python才会初始化多线程环境（主要就是创建GIL以及支持多线程的数据结构）。所以，python启动后，并不支持多线程，那些支持多线程的数据结构以及GIL都未被创建  </p>

<p>采用这种方式的原因也是合理的：倘若激活了多线程机制，即多线程环境已初始化，那么N条指令之后，Python虚拟机都会同样激活一次调度，这对于单线程的程序是完全没有必要的。生活和工作中，当然还是单线程的脚本程序多一些，所以，完全没有必要一开始就激活多线程机制，而是有用户程序自行决定  </p>

<h3>Pyhton中线程的状态保护和线程切换</h3>

<p>线程调度必然引起线程的切换，以及线程上下文的保护和恢复。Python中如何存储线程的状态（上下文）呢？  </p>

<p>答案是：每一个线程都会有一个线程状态对象与之对应，该对象是一个C 结构体，记录着有关线程所独有的一些信息：比如线程id等等  </p>

<p>所有线程的全部这些状态对象通过单向链表的方式组合起来，Python虚拟机只需要遍历链表，即可获取相关信息  </p>

<h3>后续</h3>

<p>基于这么些的线程模型，Python封装出了两个线程类库：Thread和Threading。前者由C实现，提供的接口很少，后者则为方便用户使用，属于更高层的接口  </p>

<hr/>

<p>参考：  </p>

<ul>
<li>《Python源码分析》<br/></li>
<li><a href="http://zhuoqiang.me/python-thread-gil-and-ctypes.html" target="_blank">python 线程，GIL 和 ctypes</a><br/></li>
<li><a href="http://cenalulu.github.io/python/gil-in-python/" title="gil-in-python" target="_blank">Python的GIL是什么鬼，多线程性能究竟如何</a></li>
</ul>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[Alfred使用指南]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/alfred-user-guide/"/>
        <updated>2016-01-26T15:30:00Z</updated>
        <published>2016-01-26T15:30:00Z</published>
        <id>http://sukai.me/alfred-user-guide/</id>
        <content type="html">
            <![CDATA[
             <p>Alfred是公认MAC端的神兵利器，它不仅是快速搜索工具，快速启动工具，甚至还能操作许多系统的功能。熟练使用之，完全可以抛弃鼠标，再结合MAC超强的触摸板，能节省许多时间，并提高效率  </p>

<p>今日Google之，搜索出许多详细的教程，深深感叹其高效牛逼。我参考的教程是：  </p>

<ul>
<li><a href="http://wellsnake.com/jekyll/update/2014/06/15/001/">《丢掉鼠标－Mac神软Alfred使用手册1》</a><br/></li>
<li><a href="http://wellsnake.com/jekyll/update/2014/08/16/001/">《杀手级功能WorkFlows介绍(1)-Alfred使用手册2》</a><br/></li>
</ul>

<h3>一. Alfred免费版feature</h3>

<p>看完上面的第一条链接，对于Alfred所有免费的feature就能全部掌握了，所有免费的feature有：  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/alfred-free-feature.png" alt="alfred-free-feature"/>  </p>

<p>功能不多说，上面的第一条链接介绍的很全面了。我记忆犹新的功能是：File Search&amp;&amp;Web Search  </p>

<h3>二. Alfred收费的WorkFlows</h3>

<p>WorkFlows是Alfred的核心功能，只有亲身用之，才能体会到无比的强大。其核心理念是：  </p>

<p><strong>From quick file filters to advanced scripts, you can control your Mac, other applications, web services and more.</strong>  </p>

<p>我们大可不必搞清WorkFlows的原理，对于小白用户，已经有一个收集平台为我们收集了所有可用的WorkFlow：<a href="http://www.alfredworkflow.com/">http://www.alfredworkflow.com/</a>  </p>

<p>比如，前往该平台网站，下载了我最想扩展的“搜索豆瓣电影、图书、音乐”功能：<strong>Douban (豆瓣)</strong>，下载下来的文件是：“Douban.alfredworkflow”，双击安装并import即可使用，使用效果如下：  </p>

<p>我使用“book 机器学习实战”，来控制我的MAC去<a href="http://book.douban.com">http://book.douban.com</a>搜索《机器学习实战》这本书，之后MAC会使用默认浏览器打开《机器学习实战》的douban链接  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/douban-alfred-workflow.png" alt="douban-alfred-workflow"/>  </p>

<p>除此之外，还有很多优秀的WorkFlow供你选择，你能想到的基本都已经有了，你会感叹到程序猿真的是这个世界上伟大的动物  </p>

<p>当然，你突然想到某个新颖的功能，想开发自己的WorkFlow，这也不是什么难事，难得是一个好的idea。WorkFlows可以通过用户自己写脚本语言来定制搜索和其它一些高级功能，其支持bash、zsh、php、ruby、python、perl、osascript等脚本语言，具体的这篇文章不介绍了，自行Google吧  </p>

<hr/>

<p>参考资料：  </p>

<ul>
<li><a href="http://sspai.com/27854">少数派.Alfred的5个实用扩展推荐（一）</a><br/></li>
<li><a href="http://sspai.com/27929">少数派.Alfred的5个实用扩展推荐（二）</a></li>
</ul>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[把时间当作朋友]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/make-friends-with-time/"/>
        <updated>2016-01-25T20:30:00Z</updated>
        <published>2016-01-25T20:30:00Z</published>
        <id>http://sukai.me/make-friends-with-time/</id>
        <content type="html">
            <![CDATA[
             <blockquote>
<p>“<br/>
    我有个朋友叫做时间。她跟我真可算作两小无猜，默默陪了二十多年我才开始真正认识她。她原本没有面孔，却因为我总是用文字为她拍照，而因此可以时常伴我左右。她原来无情，我却可以把她当做朋友，因为她曾经让我明白，后来也总是经常证明，无论做什么事，只要我付出耐心，她就会陪我甚至帮我等到结果，并从来都将之如实交付与我，从未令我失望。<br/>
”<br/>
&ndash; 摘自：《把时间当作朋友》.李笑来  </p>
</blockquote>

<p>大多数人都有着相同的生活轨迹，大致都会经历：幼儿园，小学，中学，高中，大学。小时候总觉得时间过得很慢，在我们童真年龄，度过一年会觉得好漫长，因为那时候的一年是我们年龄的6，7分之1。如今，不变的时间滴滴答答走满一年，我会觉得时间流逝得很快，一年缩短至我年龄的22分之1。之后，一年的长度将会越来越短，越来越短：1/30，1/50&hellip;maybe 1/100  </p>

<p>回想高三时代，面临着高考升学的压力，我们总是被时间追着跑，我们都患有时间恐慌症，学习是我们的本职工作，我们每天勤奋却又懒惰。勤奋是因为我们总能吃苦耐劳，总能按时早晨5：50起床，10：00结束晚自习，我们不厌其烦，认为付出会有回报。然而本质上我们还是黑暗面的自己，懒惰本性主导着我们。拿我的高中语文来说，我的阅读理解和作文得分一直很低，这也是造成我高考语文不及格的主要原因。我那时候迫于时间压力，总想着寻找捷径，不费吹灰之力搞定语文，所以，每天都会很勤奋，很卖力地背诵语文老师总结的阅读理解答题框架，议论文作文写作框架，我表面勤奋，实则却懒惰，因为我不肯付出时间思考和总结，不肯抬头看路  </p>

<p>越觉得时间不够用，越想一步登天，就越不肯花额外的时间静心思考，那时候的时间就是我的天敌  </p>

<p>如今，我已成为一名大四准毕业生，不管今后奔向何方，总避免不了管理时间，工作生活娱乐的时间分配，以及效率的提高，都需要我们学会管理自己。所以，管理时间的本质还是管理自己  </p>

<p>review了《暗时间》、《程序员的思维修炼》、《如何把事情做到最好》，看的书不算少，但是进步的幅度却很小。在学习的平台期，我总是没有足够的耐心度过去，不坚持持续练习，这也是我比较严重的问题之一。这也是导致我大学四年下来，没有学成扎实的功夫，没有储备好扎实牢固的知识，一事无成的主要原因。然而大脑的天性是遗忘痛苦，那些尴尬，那些非致命性的痛苦很快就被遗忘，你便会一次次原谅自己，之后你就如“温水煮青蛙”般，永无进步，直到死去。可怕的不仅如此，而是你不知道这就发生在你身上，“吾日三省”说的就是这个道理，反省进而发现自身那些不易察觉的错误和缺陷，才最关键  </p>

<p>我很庆幸自己选择了计算机专业，学习该专业对自学能力，思考能力有着潜移默化的促进。互联网作为如今全球前沿性的热点，许多非计算机专业的人也涌入浪潮，没有自学能力和思考能力，即使是本专业学生也无法安全度过互联网的深水来到达彼岸。互联网的技术更新很快，终生学习被提出，如果你拒绝学习，你会虚度光阴；你选择了学习，终有一天你会用上这些。所以，最终的形态是：你优秀的自学能力配合着阅读能力，检索能力，写作能力，终将铸就你超强的实践能力  </p>

<p>每看一次关于自我管理或者思维的书，总觉得自己重生了一次，这次我又将充满激情，面对未来许多的未知，一定要保持耐心，坚信时间可以证明一切：  </p>

<blockquote>
<p>我要控制自己的大脑，我要翻身作大脑的主人，与懒惰抗争，坚持反省，拒绝原谅和遗忘（使用记录尴尬提醒自己）。没有突破不了的平台期，每天坚持看一点，就没有看不完的书，坚持积累才是最根本的学习策略，积极去做无趣却很重要的工作！  </p>
</blockquote>

<hr/>

<p>PS：  </p>

<p>今日读完李笑来的《把时间当作朋友》，有感而发，遂写此博客</p>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[IMDB数据库结构]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/imdb-db-structure/"/>
        <updated>2016-01-15T17:00:00Z</updated>
        <published>2016-01-15T17:00:00Z</published>
        <id>http://sukai.me/imdb-db-structure/</id>
        <content type="html">
            <![CDATA[
             <p>想要获取IMDB已上映电影的相关信息数据，我立马想到的两点就是：Restful API和爬虫，但就在我google方案的过程中，我意外收获到了其他的东西：  </p>

<p>其中一个，是使用Python语言开发的<a href="http://imdbpy.sourceforge.net/index.html">IMDbPY</a>，它的作用就是帮助开发者取回和管理IMDb的电影数据库  </p>

<p>另外一个就是，IMDB网站其实提供了所有电影的数据库镜像：<a href="http://www.imdb.com/interfaces/">http://www.imdb.com/interfaces</a>  </p>

<p>顺着IMDbPy的文档，会发现一个非常实用的脚本：<a href="http://imdbpy.sourceforge.net/docs/README.sqldb.txt">imdbpy2sql.py</a>，它的作用就是将镜像文件转换为本地的数据库  </p>

<p>第一次使用，就顺着文档<a href="http://imdbpy.sourceforge.net/docs/README.sqldb.txt">http://imdbpy.sourceforge.net/docs/README.sqldb.txt</a>一步一步来，运行完脚本后，本地数据库（我用的Mysql）会得到一些IMDB的表和数据  </p>

<p>PS：下载所需的镜像文件，并运行imdbpy2sql.py脚本，我全部写成了自动化程序：  </p>
<div class="highlight"><pre><span class="c">#!/usr/bin/env python  </span>
<span class="c"># -*- coding: utf-8 -*-  </span>

<span class="kn">import</span> <span class="nn">subprocess</span>  
<span class="kn">import</span> <span class="nn">os</span>  
<span class="kn">import</span> <span class="nn">imdb</span>  

<span class="n">location</span> <span class="o">=</span> <span class="s">&#39;./dbfiles&#39;</span>  
<span class="n">imdb_script</span> <span class="o">=</span> <span class="s">&#39;./code/bin/imdbpy2sql.py&#39;</span>  
<span class="n">base_download_url</span> <span class="o">=</span> <span class="s">&#39;ftp://ftp.fu-berlin.de/pub/misc/movies/database/&#39;</span>  
<span class="n">to_download_files</span> <span class="o">=</span> <span class="p">[</span>  
    <span class="s">&#39;movie-links.list.gz&#39;</span><span class="p">,</span> <span class="s">&#39;keywords.list.gz&#39;</span><span class="p">,</span> <span class="s">&#39;directors.list.gz&#39;</span><span class="p">,</span>  
    <span class="s">&#39;editors.list.gz&#39;</span><span class="p">,</span> <span class="s">&#39;genres.list.gz&#39;</span><span class="p">,</span> <span class="s">&#39;language.list.gz&#39;</span><span class="p">,</span>  
    <span class="s">&#39;movies.list.gz&#39;</span><span class="p">,</span> <span class="s">&#39;producers.list.gz&#39;</span><span class="p">,</span> <span class="s">&#39;production-companies.list.gz&#39;</span><span class="p">,</span> <span class="s">&#39;ratings.list.gz&#39;</span><span class="p">,</span>  
    <span class="s">&#39;writers.list.gz&#39;</span><span class="p">,</span> <span class="s">&#39;countries.list.gz&#39;</span><span class="p">,</span> <span class="s">&#39;complete-cast.list.gz&#39;</span><span class="p">]</span>  

<span class="n">mysql_ip</span> <span class="o">=</span> <span class="s">&#39;localhost&#39;</span>  
<span class="n">mysql_user</span> <span class="o">=</span> <span class="s">&#39;root&#39;</span>  
<span class="n">mysql_passwd</span> <span class="o">=</span> <span class="s">&#39;1227401054&#39;</span>  
<span class="n">mysql_db</span> <span class="o">=</span> <span class="s">&#39;mrp&#39;</span>  

<span class="k">def</span> <span class="nf">download_db_files</span><span class="p">():</span>  
    <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">to_download_files</span><span class="p">:</span>  
        <span class="n">url</span> <span class="o">=</span> <span class="n">base_download_url</span> <span class="o">+</span> <span class="nb">file</span>  
        <span class="k">print</span> <span class="s">&#39;Downloading &#39;</span><span class="p">,</span> <span class="n">url</span>  
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;wget&#39;</span><span class="p">,</span> <span class="s">&#39;-P&#39;</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="n">url</span><span class="p">]</span>  
        <span class="n">t_pro</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>  
        <span class="c"># block model too slow  </span>
        <span class="c">#t_pro.wait()  </span>


<span class="k">def</span> <span class="nf">trans_db_to_local</span><span class="p">():</span>  
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>  
        <span class="n">allDone</span> <span class="o">=</span> <span class="bp">True</span>  
        <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">to_download_files</span><span class="p">:</span>  
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">location</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span> <span class="o">+</span> <span class="nb">file</span><span class="p">):</span>  
                <span class="c">#print &#39;need file: &#39;, location+file  </span>
                <span class="n">allDone</span> <span class="o">=</span> <span class="bp">False</span>  
                <span class="k">break</span>  
        <span class="k">if</span> <span class="n">allDone</span> <span class="o">==</span> <span class="bp">True</span><span class="p">:</span>  
            <span class="k">break</span>  

    <span class="k">print</span> <span class="s">&#39;Running imdbpy2sql.py begin&#39;</span>  
    <span class="c"># mysql://user:password@host/database  </span>
    <span class="n">mysql_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;mysql://&#39;</span><span class="p">,</span> <span class="n">mysql_user</span><span class="p">,</span> <span class="s">&#39;:&#39;</span><span class="p">,</span> <span class="n">mysql_passwd</span><span class="p">,</span> <span class="s">&#39;@&#39;</span><span class="p">,</span> <span class="n">mysql_ip</span><span class="p">,</span> <span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="n">mysql_db</span><span class="p">]</span>  
    <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">imdb_script</span> <span class="o">+</span> <span class="s">&#39; -d &#39;</span> <span class="o">+</span> <span class="n">location</span> <span class="o">+</span> <span class="s">&#39; -u &#39;</span> <span class="o">+</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mysql_list</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39; --mysql-force-myisam&#39;</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>  
    <span class="k">print</span> <span class="s">&#39;Running imdbpy2sql.py. over&#39;</span>  


<span class="k">def</span> <span class="nf">run</span><span class="p">():</span>  
    <span class="n">download_db_files</span><span class="p">()</span>  
    <span class="n">trans_db_to_local</span><span class="p">()</span>  

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>  
    <span class="n">run</span><span class="p">()</span>
</pre></div>

<p>下面将分析IMDB的数据库结构，从中我们可以看出IMDB数据库设计的很好，数据高度结构化，数据表无冗余（PS：说来惭愧，平时我做开发，很喜欢一张表，这样写sql语句很方便，但是缺点真的很多），  </p>

<h3>title</h3>

<p>首先，最想找的就是电影名称了吧，它存储title表里的title字段中，除此之外，title表还有些重要的信息：id和kind_id，production_year，id代表该电影的全局唯一标识，production_year表示电影上映的年份，kind_id暂时不知道，那么可以找到kind_type表，  </p>

<p>kind_type表的信息如下：  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/imdb_db_kind_type.png" width="170" height="200" align="center">  </p>

<p>我需要的是电影信息，那么就对应着kind_type为1的数据  </p>

<p>以id为2459950的电影为例子吧，在title中的数据如下：  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/imdb_title_table_ex.png"  height="100" align="center" />  </p>

<p>从图中可以看到select出来的结果为：id为249950的电影名为After Words，上映时间为2015年  </p>

<p>在imdb网站搜索下该电影，链接为：<a href="http://www.imdb.com/title/tt2226630/">http://www.imdb.com/title/tt2226630/</a>  </p>

<h3>movie_info</h3>

<p>之后，我需要电影相关的info，比如：countries, languages, genres, votes, rating  </p>

<p>首先涉及到的表式：movie_info，通过‘SELECT * FROM mrp.movie_info where movie_id=2459950;’，得到上面‘After Words’电影的相关信息如下：  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/imdb_movie_info_ex.png" width="700" height="150" align="center" />  </p>

<p>其中info_type_id不是很明白，找到info_type表，里面解释着各个id代表的含义：  </p>

<ul>
<li>id为3代表genres<br/></li>
<li>id为8代表countries<br/></li>
<li>id为4代表languages<br/></li>
</ul>

<p>结合截图select的结果，得知&#39;After Words&#39;的countries为USA，genres为Drama，languages为English  </p>

<h3>movie_info_id</h3>

<p>还有一些相关的info在movie_info_idx中，通过‘SELECT * FROM mrp.movie_info_idx where movie_id=2459950;’，得到如下结果：  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/imdb_movie_info_idx_ex.png" width="680" height="150" align="center">  </p>

<p>相应的：  </p>

<ul>
<li>info_type_id为99代表votes distribution（这个数据值我暂时没搞懂）<br/></li>
<li>info_type_id为100代表votes<br/></li>
<li>info_type_id为101代表rating<br/></li>
</ul>

<h3>movie_keywords</h3>

<p>需要查找电影的keywords信息，就需要用到movie_keywords表了。‘SELECT * FROM mrp.movie_keyword where movie_id=2459950;’：  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/movie_keywords_ex.png" width="350" height="200" align="center" />  </p>

<p>这样就可以找到电影所有的keywords_id，然后使用keywords_id去keywords表中寻找具体的值，即可：  </p>

<p>比如‘SELECT * FROM mrp.keyword where id=37348’得到的具体值为：costa-rica，这个和imdb官网是符合的，是正确的！  </p>

<h3>cast_info</h3>

<p>下面我们来找一下cast_info：cast, editor, writer, director, producer等，这些信息当然是在cast_info表中了，‘SELECT * FROM mrp.cast_info where movie_id=2459950;’:  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/cast_info_ex.png" width="700" height="700" align="center" />  </p>

<p>里面同样有个role_id，查阅role_type表：  </p>

<ul>
<li>role_id为1和2，分别代表actor和actress<br/></li>
<li>role_id为3，代表producer<br/></li>
<li>role_id为4，代表writer<br/></li>
<li>role_id为8，代表director<br/></li>
<li>rile_id为9，代表editor<br/></li>
</ul>

<p>那么如何找到具体的人名呢？通过person_id和name表，不多说，你可以试一下，再对照官网，可以发现信息是完全吻合的  </p>

<h3>movie_companies</h3>

<p>下面我们来找一下电影的production_companies，涉及到表为movie_companies，‘SELECT * FROM mrp.movie_companies where movie_id=2459950;’，之后会得到company_id  </p>

<p>拿着company_id去company_name里面即可找到具体公司名  </p>

<p>这里不再累述  </p>

<h3>额外信息</h3>

<p>还有一些额外的信息我需要知道：有关评分的信息，包括1~10评分的分布，女性评分占多少，男性多少，年龄段评分多少等等  </p>

<p>如<a href="http://www.imdb.com/title/tt2226630/ratings?ref_=tt_ov_rt">http://www.imdb.com/title/tt2226630/ratings?ref_=tt_ov_rt</a>所示  </p>

<p>方法是通过Imdbpy这个开源库里面的一个核心的函数：update，来完成（感谢东南大学杨远溢同学），他在这方面已经研究出方案了，我只需要站在他的基础上，编写程序即可  </p>

<p>实例程序如下：（搜索&quot;A Father&#39;s Journey&quot;电影，并获取评分信息）  </p>
<div class="highlight"><pre><span class="kn">import</span> <span class="nn">imdb</span>  

<span class="k">def</span> <span class="nf">init_db</span><span class="p">():</span>  
    <span class="n">title</span> <span class="o">=</span> <span class="s">&quot;A Father&#39;s Journey&quot;</span>  
    <span class="n">ia</span> <span class="o">=</span> <span class="n">imdb</span><span class="o">.</span><span class="n">IMDb</span><span class="p">()</span>  
    <span class="n">s_result</span> <span class="o">=</span> <span class="n">ia</span><span class="o">.</span><span class="n">search_movie</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>  
    <span class="sd">&#39;&#39;&#39;  </span>
<span class="sd">    for item in s_result:  </span>
<span class="sd">        print item[&#39;title&#39;]  </span>
<span class="sd">    &#39;&#39;&#39;</span>  
    <span class="n">the_unt</span> <span class="o">=</span> <span class="n">s_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  
    <span class="n">ia</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">the_unt</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;vote details&#39;</span><span class="p">))</span>  
    <span class="k">if</span> <span class="n">the_unt</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;rating&#39;</span><span class="p">):</span>  
        <span class="k">print</span> <span class="n">the_unt</span><span class="p">[</span><span class="s">&#39;rating&#39;</span><span class="p">]</span>  
    <span class="k">if</span> <span class="n">the_unt</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;number of votes&#39;</span><span class="p">):</span>  
        <span class="n">number_votes</span> <span class="o">=</span> <span class="n">the_unt</span><span class="p">[</span><span class="s">&#39;number of votes&#39;</span><span class="p">]</span>  
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">11</span><span class="p">):</span>  
            <span class="k">print</span> <span class="s">&#39;R&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">number_votes</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>  
    <span class="k">if</span> <span class="n">the_unt</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&#39;demographic&#39;</span><span class="p">):</span>  
        <span class="n">infos</span> <span class="o">=</span> <span class="p">[</span>  
            <span class="s">&#39;males&#39;</span><span class="p">,</span> <span class="s">&#39;females&#39;</span><span class="p">,</span>  
            <span class="s">&#39;aged under 18&#39;</span><span class="p">,</span> <span class="s">&#39;males under 18&#39;</span><span class="p">,</span> <span class="s">&#39;females under 18&#39;</span><span class="p">,</span>  
            <span class="s">&#39;aged 18-29&#39;</span><span class="p">,</span> <span class="s">&#39;males aged 18-29&#39;</span><span class="p">,</span> <span class="s">&#39;females aged 18-29&#39;</span><span class="p">,</span>  
            <span class="s">&#39;aged 30-44&#39;</span><span class="p">,</span> <span class="s">&#39;males aged 30-44&#39;</span><span class="p">,</span> <span class="s">&#39;females aged 30-44&#39;</span><span class="p">,</span>  
            <span class="s">&#39;aged 45+&#39;</span><span class="p">,</span> <span class="s">&#39;males aged 45+&#39;</span><span class="p">,</span> <span class="s">&#39;females aged 45+&#39;</span><span class="p">,</span>  
            <span class="s">&#39;imdb staff&#39;</span><span class="p">,</span> <span class="s">&#39;top 1000 voters&#39;</span><span class="p">,</span>  
            <span class="s">&#39;us users&#39;</span><span class="p">,</span><span class="s">&#39;non-us users&#39;</span>  
        <span class="p">]</span>  
        <span class="n">demo_value</span> <span class="o">=</span> <span class="n">the_unt</span><span class="p">[</span><span class="s">&#39;demographic&#39;</span><span class="p">]</span>  
        <span class="k">print</span> <span class="s">&#39;get&#39;</span>  
        <span class="k">for</span> <span class="n">in_fo</span> <span class="ow">in</span> <span class="n">infos</span><span class="p">:</span>  
            <span class="k">if</span> <span class="n">demo_value</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">in_fo</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>  
                <span class="k">print</span> <span class="n">in_fo</span><span class="p">,</span> <span class="n">demo_value</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">in_fo</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">demo_value</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">in_fo</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
</pre></div>

<h3>总结</h3>

<p>IMDB提供数据的方式确实很独特，通过镜像的方式。通过分析所有的表结构，不难发现imdb数据库设计之好  </p>

<p>好了，截止目前，imdb的未上映和已上映电影数据就都可以拿到了  </p>

            ]]>
        </content>
    </entry>
    
</feed>