<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>苏苏</title>
    <link href="" rel="self" />
    <link href="http://sukai.me/" />
    <updated>2016-06-20T15:50:00Z</updated>
    <id>http://sukai.me/</id>
    
    <entry>
        <title><![CDATA[读《你只是看起来很努力》]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/you-just-seem-to-be-working-hard/"/>
        <updated>2016-06-20T15:50:00Z</updated>
        <published>2016-06-20T15:50:00Z</published>
        <id>http://sukai.me/you-just-seem-to-be-working-hard/</id>
        <content type="html">
            <![CDATA[
             <p>虽说《你只是看起来很努力》书是个纯纯粹粹的鸡汤文，不过在情绪不稳定时喝喝鸡汤也无妨  </p>

<p>PS：书名起得很假大空，明明只有Part 1部分记录了有关努力的鸡汤  </p>

<p>本文主要以摘录为主  </p>

<h4>推荐序</h4>

<p>我们之所以觉着焦虑，无非是因为现在的自己和想象中的自己，很有距离。而且我们离想象中的自己越来越远，很大程度上都是因为自己在一点点地辜负自己  </p>

<p>关于焦虑，我发现我们或多或少地都陷入了一个怪圈，这个怪圈叫：我们看似忙碌，实则焦虑。我们总是心血来潮想学习，于是买了很多单词书，再也没有翻开过；我们总是备受刺激健身，于是找了很多攻略，再也没有动过；我们总是信誓旦旦要读书，于是买了很多书，再也没有打开过  </p>

<p>我们忙碌，可我们却没有真的去了解那些自己精挑细选留下的内容。我们花时间收集，却忘了最重要的其实是花时间消化  </p>

<p>那么怎么打败焦虑？最好的办法就是去做那些让你焦虑的事情  </p>

<p>逐渐，我开始每天给自己写计划，每个月给自己设定目标，不为别人部位表象地努力。路一步步地走，走得很慢，但没有停  </p>

<h4>Part 1：梦想和奋斗—你只是看起来很努力</h4>

<p><strong>你以为你在合群，其实你在浪费青春</strong>  </p>

<p>合到该合的群，寻觅自己要的，无论是理想，还是朋友，才是大学四年该做的。我一直坚信，英雄，永远是孤独的，只有小喽啰才扎堆。无论如何，那些有点成就的人，都不合群；就算表面  </p>

<p><strong>以赚钱为目的的兼职，是最愚蠢的投资</strong>  </p>

<p>那些有工作、有钱人的生活，不要羡慕，因为随着你年龄的增长，迟早会有。但是，你有而他们没有的东西：时间、青春。其实格外重要  </p>

<p><strong>最好的休息</strong>  </p>

<p>休息的方式不是疯狂地睡大觉，而是换个脑子去做其他的事情  </p>

<p>很多时候，我们觉着累，打不起精神去做一些事情；我们觉着很困，却在床上睡不着。其实，不是因为我们老了，而是因为我们没有合理运用时间。我们的时间如此宝贵，为什么不去规划地使用，很多所谓的四喜时间，根本不是去蒙头大睡，而是去调整生活状态，换个大脑。睡觉只是众多放松方式中的一种，除此之外，我们还有很多方法  </p>

<p><strong>优秀不够，你是否无可替代</strong>  </p>

<p>毕竟努力的人很多，在大城市，最不缺的就是梦想，最不差的就是优秀的人  </p>

<p>年轻人，在学习的路上，不要低着头看书，多去人才市场看看现在的社会需要什么专长，上网看看大型公司缺的施恩么人，把一技之长磨得无可替代，变成自己喜欢的事业  </p>

<p><strong>这世上一定有人，过着你想要的生活</strong>  </p>

<p><strong>没有一条路是白走的</strong>  </p>

<p>有时候只有走错了路，才逐渐明白自己要的未来；只有交错了朋友，才逐渐知道什么是患难见真情；只有爱错过人，才逐渐懂得真爱是什么  </p>

<p><strong>别和负能量的人在一起</strong>  </p>

<p>**为什么很多人的新年梦想只是梦想  </p>

<p>我在上课的时候，特别喜欢培养学生写日记的习惯。我告诉所有的学生，如果你不愿意写，也要在夜晚睡觉前闭目养神地静静思考一下今天做了什么，明天还要做什么。思考的时候要分成必须做的、喜欢做的和可做可不做的  </p>

<p><strong>最好的省钱方法是赚钱</strong>  </p>

<p>虽然钱不是万能的，但是没有钱你会发现寸步难行。那之后，我学会了不跟别人斗争，很多时候网上有人对我发起了攻击，我唯一能做的，就是回避。因为这些斗争米有意义，而有这些时间，还不如多多提升自己或者多去赚点钱  </p>

<p>中国有一句古话，思路决定出路，屁股决定脑袋。一个脑袋里面整天只有几角钱的人，相比这辈子不会赚什么大钱；一个只会知道如何省钱的人，也自然而然地失去了如何赚钱的思维。我不是让大家去浪费，可你是否想过，一些过于节省的生活，就是浪费：你每天都在争论那几角钱，浪费了精力和时间去读书学习；把隔夜的剩菜热了吃，吃坏肚子去医院花更多钱。真正省钱的方式，是去赚钱，是让自己变得更强大，而不是为了几角钱花自己最宝贵的时间去永无休止地争论  </p>

<p><strong>你总要度过生存期，才能谈生活和梦想</strong>  </p>

<p>无论在哪里，你都先要解决生存的问题，然后谈生活和梦想。我想，任何梦想和生活，都是基于度过生存期那段连下个馆子都计划再三的时光后的，否则，都是空中楼阁。在度过生存期的过程中，可能会失去一些宝贵的东西，或过得不如意。但不忘初心，记得每天提醒自己：这些黑暗只是为了今后的黎明，做这些不愿意的事情只是为了以后能更好地站起来。这样便好</p>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[2016上半年书单]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/2016-first-half-booklists/"/>
        <updated>2016-06-19T16:30:00Z</updated>
        <published>2016-06-19T16:30:00Z</published>
        <id>http://sukai.me/2016-first-half-booklists/</id>
        <content type="html">
            <![CDATA[
             <p>大概是3月份入手了Kindle PaperWhite 3，发现真的很喜欢这个电子阅读器。所以平时的阅读习惯就变成了从readcolor.com和readfree.me下载许多mobi书籍存在Kindle上。有时候下载些epub的在果6的多看阅读上浏览  </p>

<p>我上半年似乎看了不少小说（：逃，下面就粗略地从自己的评分由高往低简单记录下  </p>

<ul>
<li><strong>《孤独小说家》</strong>：书名虽然叫作“孤独小说家”，讲的是一位小说家青田耕平坚持写作十年，才收获梦想拿到直本奖。但给我留下最深刻印象的是耕平丧妻后仍不浮躁、坚守内心纯真孤独的那份难得可贵<br/></li>
<li><strong>《岛上书店》</strong>：本以为玛雅的出现拯救了A.J.，没想到结局还是不尽人意，这就是生活<br/></li>
<li><strong>《时间简史：从大爆炸到黑洞》</strong>：这是本只有全球5%的人才能看懂的书，可惜我不是那5%。但这又是一本让你有些熟悉的书，里面有部分结论在高中物理，大学物理都有所涉及，里面还有部分结论和猜想被众多科幻片引入。有机会会翻阅第二遍<br/></li>
<li><strong>《统计学习方法》</strong>：机器学习入门经典书籍<br/></li>
<li><strong>《机器学习实战》</strong>：理论看多了，来点代码非常不错<br/></li>
<li><strong>《高效能程序员的修炼》</strong>：教你如何做一名敏捷式程序员，和《高效程序员的45个习惯》有重合观点<br/></li>
<li><strong>《把时间当作朋友》</strong>：非常好的一本书，不多说<br/></li>
<li><strong>《奇特的一生》</strong>：李笑来推荐的书。柳比歇夫一直在算自己每天的24小时都花在了什么地方，相当自律的一个人，警告自己珍惜时间<br/></li>
<li><strong>《富爸爸穷爸爸》</strong>：坚定了自己未来要给自己打工的决心<br/></li>
<li><strong>《深入浅出统计学》</strong>：回顾“统计学”的一本好书<br/></li>
<li><strong>《拉伸：最好的运动》</strong>：作为一名程序员，拉伸很有必要。书里附送了一张拉伸教程表，可以学习下<br/></li>
<li><strong>《Python科学计算》</strong>：不错的一本工具书。教你如何利用Python进行科研<br/></li>
<li><strong>《重来：更为简单有效的商业思维》</strong>：有关创业的<br/></li>
<li><strong>《从0到1：开启商业与未来的秘密》</strong>：另一本有关创业的<br/></li>
<li><strong>《你今天真好看》</strong>：很好看的漫画，很萌<br/></li>
<li><strong>《父与子全集》</strong>：又一本萌萌哒的漫画，父与子之间的故事<br/></li>
<li><strong>《赤裸裸的统计学》</strong>：结合实际案例讲述的入门级统计学科普书，不推荐你逐字逐句去细读<br/></li>
<li><strong>《台湾这些年所知道的祖国》</strong><br/></li>
<li><strong>《不要等到毕业以后》</strong>：里面相当多的观点深有体会<br/></li>
<li><strong>《别告诉我你会记笔记》</strong>：有些关于做笔记的建议还是值得采纳的。特别是将脑袋中瞬息的灵感记在本子上，并写写画画，思绪更容易被激发<br/></li>
<li><strong>《4点起床》</strong>：这本书最大的收获就是提醒你珍惜时间，尤其是早晨上半午的时间<br/></li>
<li><strong>《考拉小巫的英语学习笔记》</strong>：作者的执行力很强，令人佩服。自己是自愧不如了<br/></li>
<li><strong>《Automate the Boring Stuff with Python》</strong>：教你如何利用Python帮你处理一些繁琐的事<br/></li>
<li><strong>《少有人走得路》</strong>：偏心理学的书。书中讲：大部分人不愿意正视“人生苦难重重”，总会选择先享受，然后逃避问题和痛苦，这句说得太好了。所以每个工作日的早晨都应该推迟满足感，首先在工作的第一个钟头去解决那些最麻烦的事情，即先吃苦再享受<br/></li>
<li><strong>《天才在左，疯子在右》</strong>：若不是书名的提醒，你不会发现这本书是记录精神病患者的。那些精神病患者的想象力、智力似乎都比正常人惊人的高，令人吃惊<br/></li>
<li><strong>《Introducing Github》</strong>：介绍Github的一本书<br/></li>
<li><strong>《Think Python》</strong><br/></li>
<li><strong>《绿皮火车》</strong>：为什么读起来很费力，不轻松<br/></li>
<li><strong>《哪来的天才？》</strong>：keep practiceing<br/></li>
<li><strong>《创业时，我们在知乎聊什么？》</strong>：如果自己真的创业了，回来会仔细品读的<br/></li>
<li><strong>《深入浅出数据分析》</strong>：个人觉着不如《深入浅出统计学》<br/></li>
<li><strong>《重新定义公司》</strong>：Google发展史，里面有一章讲google为什么退出中国市场的<br/></li>
<li><strong>《创京东</strong>》：京东发展史，没有细看。很佩服刘强东，事业有成，还有奶茶妹妹，人生赢家<br/></li>
<li><strong>《敏感的人：如何面对外界的压力》</strong><br/></li>
<li><strong>《轻松学会独立思考》</strong><br/></li>
<li><strong>《我们台湾这些年》</strong>：流水账文章，比不上《台湾这些年所知道的祖国》<br/></li>
<li><strong>《大数据时代》</strong>：泛泛而谈的一本书<br/></li>
<li><strong>《大教堂与集市》</strong>：看得翻译本，不是很能懂<br/></li>
<li><strong>《中国人，你为什么不快乐》</strong><br/></li>
<li><strong>《沉默的大多数》</strong><br/></li>
<li><strong>《那些男孩教我的事》</strong><br/></li>
<li><strong>《黑客：计算机革命的英雄》</strong><br/></li>
<li><strong>《我这个普通人的生活》</strong><br/></li>
<li><strong>《十四岁》</strong>：日本人14岁的时候就开始找女生援交了？<br/></li>
<li><strong>《互联网+：从IT到DT》</strong><br/></li>
<li><strong>《年轻时做过的那些荒唐事儿》</strong><br/></li>
<li><strong>《生命中最简单又困难的事》</strong><br/></li>
<li><strong>《当你生病时，你会想起谁？》</strong><br/></li>
</ul>

<p>总共48本，下半年继续坚持</p>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[毕业了]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/bachelor-degree/"/>
        <updated>2016-06-19T00:32:00Z</updated>
        <published>2016-06-19T00:32:00Z</published>
        <id>http://sukai.me/bachelor-degree/</id>
        <content type="html">
            <![CDATA[
             <p>四年前，从高中踏入大学的大门，从未幻想过毕业时的我会是怎样的，至少应该不会成为家里的拖油瓶吧  </p>

<p>这段时间的朋友圈充斥着毕业的快乐和感恩，所以本以为这份大学毕业总结会非常好些，没想到真的很伤脑筋。记得去年参加学长学姐的毕业生晚会时，心里还有几分激动。今年可能是因为我没有参加班级聚会和毕业生晚会，所以真的没什么情感和灵感去写这篇总结  </p>

<p>现在越来越能体会到学生是一生最穷的时刻。但是倘若以后有钱有权了，时间就会变少了。生活的过程就是拿一味东西去换另一味东西。所以首先需要告诉自己：还有三年又要毕业啦！在我心里，读书是人生最幸福的时刻，如果我之后硕士科研成果可以的话，我还是会选择继续读下去，博士吧  </p>

<p>大学里面是有挺后悔的事情的，大概这些事情的原因都是由于自己太盲目跟风了吧。而且我发现大学生麻木跟风的人不在少数，个人感觉自己大三之后才开始规划自己的路线。比如，进入某组织，成为某组织的一员；学生会的社团一职等等  </p>

<p>也越来越能体会到什么是理想、什么是现实，理想和现实有差距，说和做是两码事。但是不管怎样，自己也一直在成熟，不过我这个瓜熟得很慢。但是至少某些关键节点的大事情还是under control的，算是给自己的安慰吧  </p>

<p>从五月一号开始的未来好几年，至少硕士三年都要定居南京了。想想硕士期间住在学校，假期就可以乘着地铁回家，也是件蛮爽的事。想想这段时间的状态一直不好，没有什么学习和看书的感觉。我已经在心里给自己放假了，6月底去研究生实验室报道，月底前好好玩一玩吧，陪YAOYAO，陪老姐。我也已经预感到研究生期间会遇到各种deadline，只是现在还没有做好抗压的准备，不过状态终究会被我找回来的  </p>

<p>夜深，有点困意，胡乱写写，算是糊“任务”吧  </p>

<p>2016-06-19 00:32PM 于NanJing.</p>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[virtualenv小实践]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/python-virtualenv/"/>
        <updated>2016-04-26T12:35:00Z</updated>
        <published>2016-04-26T12:35:00Z</published>
        <id>http://sukai.me/python-virtualenv/</id>
        <content type="html">
            <![CDATA[
             <p>说来也巧，前几天想在mac上同时安装python2.x和3.4，当时为了省事没有使用virtualenv，直接采用了Homebrew Install。这几天遇到了不同application需要依赖不用版本tornado的问题，本想采用docker解决的，想想没必要，直接使用virtualenv更轻量级些  </p>

<p>注：<a href="https://link.zhihu.com/?target=https%3A//www.quora.com/Whats-the-best-way-to-set-up-Python-2-7-and-3-4-in-parallel-on-a-Mac">Homebrew Install</a>安装python2.x和3.4  </p>

<p>简而言之：我的某个app，<a href="https://github.com/whtsky/Catsup">catsup</a>博客系统需要3.2版本的tornado，而tornado3.2不能应用于本人制作的毕设网站，需要最新tornado版本4.x。所以采用virtualenv虚拟环境方便又简单，当然docker也是可以解决的哦~  </p>

<p>关于virtualenv的概念，作用，安装，使用，就不说了，我主要参考了以下user guide  </p>

<ul>
<li><a href="http://lcblog-wordpress.stor.sinaapp.com/uploads/2015/10/virtualenv%E6%95%99%E7%A8%8B.pdf">virtualenv教程</a><br/></li>
<li><a href="http://virtualenv.readthedocs.org/en/latest/userguide.html">virtual user guide</a><br/></li>
<li><a href="http://qicheng0211.blog.51cto.com/3958621/1561685">使用virtualenv搭建独立的Python环境</a><br/></li>
</ul>

<p>总的来说，just use some simple commands：  </p>
<div class="highlight"><pre><span class="n">sudo</span> <span class="n">pip</span> <span class="n">install</span> <span class="n">virtualenv</span>  
<span class="c"># 创建虚拟环境ENV2.7，ENV2.7只是虚拟环境名，可任意取  </span>
<span class="n">virtualenv</span> <span class="o">--</span><span class="n">python</span><span class="o">=</span><span class="n">python2</span><span class="o">.</span><span class="mi">7</span> <span class="o">--</span><span class="n">no</span><span class="o">-</span><span class="n">site</span><span class="o">-</span><span class="n">packages</span> <span class="n">ENV2</span><span class="o">.</span><span class="mi">7</span>  
<span class="c"># 进入虚拟环境  </span>
<span class="n">cd</span> <span class="n">ENV2</span><span class="o">.</span><span class="mi">7</span>  
<span class="c"># 激活虚拟环境  </span>
<span class="n">source</span> <span class="nb">bin</span><span class="o">/</span><span class="n">activate</span>  
<span class="c"># 在虚拟环境中可以进行任何单独的操作，库安装。此时不影响本机全局环境  </span>
<span class="n">pip</span> <span class="n">install</span> <span class="n">catsup</span>  
<span class="c"># 进入源代码目录，xxx目录下面的源代码依赖ENV2.7 虚拟环境  </span>
<span class="n">cd</span> <span class="n">xxx</span>  
<span class="c"># 进行操作  </span>
<span class="n">catup</span> <span class="n">server</span>  
<span class="c"># 关闭虚拟环境  </span>
<span class="n">deactivate</span>
</pre></div>

<p>简单地记录下，之后关于virtualenv方面的使用心得，再进行补充</p>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[Python中的排序总结]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/sorting-in-python/"/>
        <updated>2016-04-19T16:30:00Z</updated>
        <published>2016-04-19T16:30:00Z</published>
        <id>http://sukai.me/sorting-in-python/</id>
        <content type="html">
            <![CDATA[
             <p>笔者阅读外文博客，整理了Python中List, Tuple, Dictionary三类常见数据结构的相关排序的tips  </p>

<h3>一. 对List（或Tuple）进行排序</h3>

<h4>1.1 最简单的List排序</h4>

<p>假设我们有一组数字列表：<code>a = [3,6,8,2,78,1,23,45,9]</code>  </p>

<p>我们可以通过<code>sort</code>方法和<code>sorted</code>方法对a进行排序。两者的区别在于：<code>sort</code>是list自带的方法，它会将原先的list直接修改为排序完成后的list；<code>sorted</code>方法不会修改原先的list，而是返回一个新的排序后的list  </p>

<pre><code>&gt;&gt;&gt; sorted(a)  
[1, 2, 3, 6, 8, 9, 23, 45, 78]  
&gt;&gt;&gt;  
&gt;&gt;&gt; a.sort()  
&gt;&gt;&gt; a  
[1, 2, 3, 6, 8, 9, 23, 45, 78]</code></pre>

<p>如果要求逆序，可以：  </p>

<pre><code>&gt;&gt;&gt; sorted(a, reverse=True)  
&gt;&gt;&gt;  
&gt;&gt;&gt; a.sort(reverse=True)</code></pre>

<p><code>sort</code>和<code>sorted</code>执行时都会调用每个对象的<code>__cmp__</code>方法，该方法用于比较相关值，以便决定排序的结果  </p>

<h4>1.2 最简单的Tuple排序</h4>

<p>tuple排序和list类似，只不过python的tuple是不可变对象，所以只能用<code>sorted</code>了  </p>

<pre><code>&gt;&gt;&gt; tup = (3, 6, 8, 2, 78, 1, 23, 45, 9)  
&gt;&gt;&gt; sorted(tup)  
[1, 2, 3, 6, 8, 9, 23, 45, 78]</code></pre>

<h4>1.3 对一组列表或者元组进行排序</h4>

<p>首先我们需要确定：依据每个元素（该元素是list或者tuple）中的第几个元素进行排序呢？  </p>

<p>只需要给<code>sorted</code>或者<code>sort</code>传入key参数指定排序依据的key即可  </p>

<pre><code>&gt;&gt;&gt; def getKey(item):  
...     return item[0]  
&gt;&gt;&gt; l = [[2, 3], [6, 7], [3, 34], [24, 64], [1, 43]]  
&gt;&gt;&gt; sorted(l, key=getKey)  
[[1, 43], [2, 3], [3, 34], [6, 7], [24, 64]]</code></pre>

<p>同样的，依据第二个元素排序  </p>

<pre><code>def getKey(item):  
    return item[1]</code></pre>

<p>一组tuple的排序同上  </p>

<pre><code>&gt;&gt;&gt; a = [(2, 3), (6, 7), (3, 34), (24, 64), (1, 43)]  
&gt;&gt;&gt; sorted(l, key=getKey)  
[(1, 43), (2, 3), (3, 34), (6, 7), (24, 64)]</code></pre>

<h4>1.4 对一组自定义对象进行排序</h4>

<pre><code>class Custom(object):  
    def __init__(self, name, number):  
        self.name = name  
        self.number = number  

    def __repr__(self):  
        return &#39;{}: {} {}&#39;.format(self.__class__.__name__,  
                                  self.name,  
                                  self.number)  

customlist = [  
    Custom(&#39;object&#39;, 99),  
    Custom(&#39;michael&#39;, 1),  
    Custom(&#39;theodore the great&#39;, 59),  
    Custom(&#39;life&#39;, 42)  
]</code></pre>

<p>依据number对customlist进行排序  </p>

<pre><code>def getKey(custom):  
    return custom.number  

&gt;&gt;&gt; sorted(customlist, key=getKey)  
[Custom: michael 1, Custom: life 42,  
Custom: theodore the great 59, Custom: object 99]</code></pre>

<p>我们也可以不使用key参数，使用<code>__cmp__</code>  </p>

<pre><code>class Custom(object):  
    def __init__(self, name, number):  
        self.name = name  
        self.number = number  

    def __repr__(self):  
        return &#39;{}: {} {}&#39;.format(self.__class__.__name__,  
                                  self.name,  
                                  self.number)  

    def __cmp__(self, other):  
        if hasattr(other, &#39;number&#39;):  
            return self.number.__cmp__(other.number)</code></pre>

<pre><code>&gt;&gt;&gt; sorted(customlist)  
[Custom: michael 1, Custom: life 42, Custom: theodore the great 59, Custom: object 99]</code></pre>

<h4>1.5 对一组由不同对象组成的list进行排序</h4>

<pre><code>class AnotherObject(object):  
    def __init__(self, tag, age, rate):  
        self.tag = tag  
        self.age = age  
        self.rate = rate  

    def __repr__(self):  
        return &#39;{}: {} {} {}&#39;.format(self.__class__.__name__,  
                                     self.tag,  
                                     self.age, self.rate)  

    def __cmp__(self, other):  
        if hasattr(other, &#39;age&#39;):  
            return self.age.__cmp__(other.age)</code></pre>

<pre><code>customlist = [  
    Custom(&#39;object&#39;, 99),  
    Custom(&#39;michael&#39;, 1),  
    Custom(&#39;theodore the great&#39;, 59),  
    Custom(&#39;life&#39;, 42),  
    AnotherObject(&#39;bananas&#39;, 37, 2.2),  
    AnotherObject(&#39;pants&#39;, 73, 5.6),  
    AnotherObject(&#39;lemur&#39;, 44, 9.2)  
]</code></pre>

<pre><code>&gt;&gt;&gt; sorted(customlist)  
Traceback (most recent call last):  
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;  
TypeError: an integer is required</code></pre>

<p>这时候我们会得到一个错误。因为Custom并没有age属性，AnotherObject并没有number属性。我们只需要重新定义我们的两个类即可  </p>

<pre><code>class Custom(object):  
    def __init__(self,name,number):  
        self.name = name  
        self.number = number  

    def __repr__(self):  
        return &#39;{}: {} {}&#39;.format(self.__class__.__name__,  
                                  self.name,  
                                  self.number)  

    def __cmp__(self, other):  
        if hasattr(other, &#39;getKey&#39;):  
            return self.getKey().__cmp__(other.getKey())  

    def getKey(self):  
        return self.number  


class AnotherObject(object):  
    def __init__(self, tag, age, rate):  
        self.tag = tag  
        self.age = age  
        self.rate = rate  

    def __repr__(self):  
        return &#39;{}: {} {} {}&#39;.format(self.__class__.__name__,  
                                     self.tag,  
                                     self.age, self.rate)  

    def __cmp__(self, other):  
        if hasattr(other, &#39;getKey&#39;):  
            return self.getKey().__cmp__(other.getKey())  

    def getKey(self):  
        return self.age</code></pre>

<pre><code>&gt;&gt;&gt; sorted(customlist)  
[Custom: michael 1, AnotherObject: bananas 37 2.2,  
Custom: life 42, AnotherObject: lemur 44 9.2,  
Custom: theodore the great 59, AnotherObject: pants 73 5.6,  
Custom: object 99]</code></pre>

<p>我们也可以使用key参数完成  </p>

<pre><code>def getKey(customobj):  
    return customobj.getKey()</code></pre>

<pre><code>&gt;&gt;&gt; sorted(customlist, key=getKey)  
[Custom: michael 1, AnotherObject: bananas 37 2.2,  
Custom: life 42, AnotherObject: lemur 44 9.2,  
Custom: theodore the great 59, AnotherObject: pants 73 5.6,  
Custom: object 99]</code></pre>

<h3>二. 对Dictionary进行排序</h3>

<p>需要注意的是：我们无法对一个dict进行真正的排序，因为dict是内置无序的，我们所说的排序是返回一个排序完成后的表示，本质是一个list或者一组tuple等等  </p>

<p>假设我们有dict如下：<code>numbers = {&#39;first&#39;: 1, &#39;second&#39;: 2, &#39;third&#39;: 3, &#39;Fourth&#39;: 4}  
</code>  </p>

<h4>2.1 根据keys对dict进行排序</h4>

<p>如果我们需要根据dict的keys进行排序，最简单的方式就是使用内建方法<code>sorted</code>（dict没有sort方法），它会返回一组排序好的keys list。  </p>

<pre><code>&gt;&gt;&gt; sorted(numbers)  
[&#39;fourth&#39;, &#39;first&#39;, &#39;second&#39;, &#39;third&#39;]</code></pre>

<h4>2.2 根据values对dict进行排序</h4>

<p>依然可以使用<code>sorted</code>解决  </p>

<pre><code>&gt;&gt;&gt; sorted(numbers.value())  
[1,2,3,4]</code></pre>

<h4>2.3 自定义dict排序：通过keys（values）来对values（keys）排序，并只返回values（keys）</h4>

<p>通过values对keys排序  </p>

<pre><code># Use the __getitem__ method as the key function  
&gt;&gt;&gt; sorted(numbers, key=numbers.__getitem__)  
# In order of sorted values: [1, 2, 3, 4]  
[&#39;first&#39;, &#39;second&#39;, &#39;third&#39;, &#39;Fourth&#39;]</code></pre>

<p>通过keys来对values排序  </p>

<pre><code># Uses the first element of each tuple to compare  
&gt;&gt;&gt; [value for (key, value) in sorted(numbers.items())]  
[4, 1, 2, 3]  
# In order of sorted keys: [&#39;Fourth&#39;, &#39;first&#39;, &#39;second&#39;, &#39;third&#39;]</code></pre>

<p>逆序  </p>

<pre><code>&gt;&gt;&gt; sorted(numbers, key=numbers.__getitem__, reverse=True)  
[&#39;Fourth&#39;, &#39;third&#39;, &#39;second&#39;, &#39;first&#39;]  
&gt;&gt;&gt; [value for (key, value) in sorted(numbers.items(), reverse=True)]  
[3, 2, 1, 4]</code></pre>

<h4>2.4</h4>

<pre><code># Won&#39;t change the items to be returned, only while sorting  
&gt;&gt;&gt; sorted(numbers, key=str.lower)  
[&#39;first&#39;, &#39;Fourth&#39;, &#39;second&#39;, &#39;third&#39;]</code></pre>

<pre><code>&gt;&gt;&gt; month = dict(one=&#39;January&#39;,  
                 two=&#39;February&#39;,  
                 three=&#39;March&#39;,  
                 four=&#39;April&#39;,  
                 five=&#39;May&#39;)</code></pre>

<pre><code>&gt;&gt;&gt; numbermap = {&#39;one&#39;: 1, &#39;two&#39;: 2, &#39;three&#39;: 3, &#39;four&#39;: 4, &#39;five&#39;: 5}  
&gt;&gt;&gt; sorted(month, key=numbermap.__getitem__)  
[&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39;]</code></pre>

<p>如果我想根据字符串中重复字母出现的次数进行排序：  </p>

<pre><code>def repeats(string):  
    # Lower the case in the string  
    string = string.lower()  

    # Get a set of the unique letters  
    uniques = set(string)  

    # Count the max occurrences of each unique letter  
    counts = [string.count(letter) for letter in uniques]  
    return max(counts)</code></pre>

<pre><code># From greatest to least repeats  
&gt;&gt;&gt; sorted(month.values(), key=repeats, reverse=True)  
[&#39;February&#39;, &#39;January&#39;, &#39;March&#39;, &#39;April&#39;, &#39;May&#39;]</code></pre>

<h4>2.5 一些更高级的排序功能</h4>

<pre><code>trans = dict(January=33, February=30, March=24, April=0, May=7)</code></pre>

<p>对value提出某种特定要求的排序：偶数比奇数优先  </p>

<pre><code>def evens1st(num):  
    # Test with modulus (%) two  
    if num == 0:  
        return -2  
    # It&#39;s an even number, return the value  
    elif num % 2 == 0:  
        return num  
    # It&#39;s odd, return the negated inverse  
    else:  
        return -1 * (num ** -1)</code></pre>

<pre><code>&gt;&gt;&gt; sorted(trans.values(), key=evens1st, reverse=True)  
[30, 24, 33, 7, 0]</code></pre>

<h4>2.6 根据key和value排序，并返回排序之后的（key, value）组合</h4>

<pre><code>import operator  
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}  
sorted_x = sorted(x.items(), key=operator.itemgetter(1))</code></pre>

<pre><code>import operator  
x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}  
sorted_x = sorted(x.items(), key=operator.itemgetter(0)</code></pre>

<hr/>

<p>本文翻译自：  </p>

<ul>
<li><a href="http://pythoncentral.io/how-to-sort-a-list-tuple-or-object-with-sorted-in-python/" target="_blank">pythoncentral-sort-list-tuple</a><br/></li>
<li><a href="http://pythoncentral.io/how-to-sort-python-dictionaries-by-key-or-value/" target="_blank">pythoncental-sort-dictionary</a></li>
</ul>

            ]]>
        </content>
    </entry>
    
</feed>