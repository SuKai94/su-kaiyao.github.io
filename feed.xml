<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>苏苏</title>
    <link href="" rel="self" />
    <link href="http://sukai.me/" />
    <updated>2015-11-21T10:00:00Z</updated>
    <id>http://sukai.me/</id>
    
    <entry>
        <title><![CDATA[自顶向下学习Tornado源码(一)]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/tornado-source-code-one/"/>
        <updated>2015-11-21T10:00:00Z</updated>
        <published>2015-11-21T10:00:00Z</published>
        <id>http://sukai.me/tornado-source-code-one/</id>
        <content type="html">
            <![CDATA[
             <h3>一. 从Hello Tornado开始</h3>

<h4>1.1 Hello World</h4>

<p>用tornado写的一个最简单的demo，但已经用到了很多tornado的核心类：httpserver, ioloop, Application&hellip;  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/hello-tornado.png" width = "500" height = "400" alt="tornado-demo" align=center />  </p>

<h4>1.2 调试运行</h4>

<p>利用pdb进行调试，打印方法栈信息，在IndexHandler中加入代码：  </p>
<div class="highlight"><pre><span class="n">greeting</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_argument</span><span class="p">(</span><span class="s">&#39;greeting&#39;</span><span class="p">,</span> <span class="s">&#39;Hello&#39;</span><span class="p">)</span>  
<span class="kn">import</span> <span class="nn">pdb</span>  
<span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>   
<span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">greeting</span> <span class="o">+</span> <span class="s">&#39;, friendly user!&#39;</span><span class="p">)</span>
</pre></div>

<p>利用curl或者浏览器，触发程序，查看栈桢  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/stack-hello-tornado.png" width = "500" height = "400" alt="stack-tornado-demo" align=center />  </p>

<h4>1.3 猜测</h4>

<p>图中模模糊糊给了我们一些执行流程信息，我又参考了几篇文章，先得出一些结论  </p>

<ul>
<li>ioloop：核心的io循环，用于处理所有socket的read, write, accept等事件。其i/o模型视主机而定，一般Linux平台采用epoll(关于i/o模型，<a href="http://sukai.me/linux-five-io-models/">Click For More..</a>)<br/></li>
<li>iostream：封装了对socket的异步读写操作<br/></li>
<li>httpConnection(代码在httpserver.py中)：接受HTTP请求，根据路由信息，调用相应的Handler。再把相应的数据写会client<br/></li>
</ul>

<p>tornado服务器的大体流程如下图(图片来源：<a href="http://kenby.iteye.com/blog/1159621">kenby.iteye</a>)  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/tornado-core.png" width = "500" height = "400" alt="tornado-core" align=center />  </p>

<p>首先，服务器创建监听套接字，同时将自己注册进ioloop进行事件循环检查（主要检查是否有新的客户端连接到来）。client到达后，服务器通过accept函数，返回一个client socket，同时client socket被注册进ioloop进行事件循环检查（检查read，write等事件）。客户端若向服务器发起读操作，HTTPConnetcion通过_on_headers解析HTTP头，之后通过iostream的write操作，将数据写给客户端  </p>

<h3>二. HTTPServer</h3>

<p>按照自顶向下的顺序，先阅读HTTPServer的源码  </p>

<p>HTTPServer继承自TCPServer  </p>

<p>刚刚的demo中，与HTTPServer相关的只有两条编程语句  </p>
<div class="highlight"><pre><span class="n">http_server</span> <span class="o">=</span> <span class="n">tornado</span><span class="o">.</span><span class="n">httpserver</span><span class="o">.</span><span class="n">HTTPServer</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>  
<span class="n">http_server</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="n">options</span><span class="o">.</span><span class="n">port</span><span class="p">)</span>
</pre></div>

<p>先是初始化函数  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/tornado-httpserver-init.png" width = "600" height = "400" alt="tornado-httpserver-init" align=center />  </p>

<p>就是简单地初始化一些参数，然后就是父类的初始化。最主要的是这个request_callback，我们传进去的是Application实例，里面有我们自己配制的路由信息，到时候tornado服务器会根据我们的路由信息，将相应的路由请求转发给相应的RequestHandler。  </p>

<p>然后是<code>listen</code>监听，HTTPServer没有覆写父类TCPServer的listen函数，直接看TCPServer的listen：  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/tornado-tcpsever-listen.png" width = "500" height = "200" alt="tornado-tcpserver-listen" align=center />  </p>

<p>先调用了<code>bind_socket</code>，该函数在netutil.py中：  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/netutil-bind_socket.png" width = "550" height = "100" alt="netutil-bind_socket" align=center />  </p>

<p>代码就不看了，功能很简单，我截图了该函数的doc string，根据给定的地址和端口，创建一系列的listening sockets  </p>

<p>之后<code>listen</code>函数调用了<code>self.add_sockets(sockets)</code>，我们来看一下<code>add_sockets</code>：  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/tcpserver-add_sockets.png" width = "650" height = "320" alt="tornado-tcpserver-add_sockets" align=center />  </p>

<p>通过<code>add_accept_handler(sock, self._handle_connection, io_ioop=elf.io_loop)</code>将一系列的listen sockets注册进ioloop（ioloop的作用就是利用epoll，轮询检查所有套接字的io事件，效率很高，是tornado并发量突出的重要原因）  </p>

<p>仔细看一下<code>add_accept_handler()</code>，它在netuilt.py中：  </p>
<div class="highlight"><pre><span class="k">if</span> <span class="n">io_loop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>  
    <span class="n">io_loop</span> <span class="o">=</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">current</span><span class="p">()</span>  

<span class="k">def</span> <span class="nf">accept_handler</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">events</span><span class="p">):</span>  
    <span class="c"># More connections may come in while we&#39;re handling callbacks;  </span>
    <span class="c"># to prevent starvation of other tasks we must limit the number  </span>
    <span class="c"># of connections we accept at a time.  Ideally we would accept  </span>
    <span class="c"># up to the number of connections that were waiting when we  </span>
    <span class="c"># entered this method, but this information is not available  </span>
    <span class="c"># (and rearranging this method to call accept() as many times  </span>
    <span class="c"># as possible before running any callbacks would have adverse  </span>
    <span class="c"># effects on load balancing in multiprocess configurations).  </span>
    <span class="c"># Instead, we use the (default) listen backlog as a rough  </span>
    <span class="c"># heuristic for the number of connections we can reasonably  </span>
    <span class="c"># accept at once.  </span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">_DEFAULT_BACKLOG</span><span class="p">):</span>  
        <span class="k">try</span><span class="p">:</span>  
            <span class="n">connection</span><span class="p">,</span> <span class="n">address</span> <span class="o">=</span> <span class="n">sock</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>  
        <span class="k">except</span> <span class="n">socket</span><span class="o">.</span><span class="n">error</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  
            <span class="c"># _ERRNO_WOULDBLOCK indicate we have accepted every  </span>
            <span class="c"># connection that is available.  </span>
            <span class="k">if</span> <span class="n">errno_from_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="n">_ERRNO_WOULDBLOCK</span><span class="p">:</span>  
                <span class="k">return</span>  
            <span class="c"># ECONNABORTED indicates that there was a connection  </span>
            <span class="c"># but it was closed while still in the accept queue.  </span>
            <span class="c"># (observed on FreeBSD).  </span>
            <span class="k">if</span> <span class="n">errno_from_exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">==</span> <span class="n">errno</span><span class="o">.</span><span class="n">ECONNABORTED</span><span class="p">:</span>  
                <span class="k">continue</span>  
            <span class="k">raise</span>  
        <span class="n">callback</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>  
<span class="n">io_loop</span><span class="o">.</span><span class="n">add_handler</span><span class="p">(</span><span class="n">sock</span><span class="p">,</span> <span class="n">accept_handler</span><span class="p">,</span> <span class="n">IOLoop</span><span class="o">.</span><span class="n">READ</span><span class="p">)</span>
</pre></div>

<p>利用<code>io_loop.add_handler(sock, accept_handler, IOLoop.READ)</code>，将listen socket注册进ioloop，等待READ事件发生。发生后即回调<code>accept_handler</code>函数，该函数里面有<code>sock.accept()</code>方法，接受客户端连接，之后再调用<code>callback(connection, address)</code>。这里的callback函数就是我们调用<code>add_accept_handler()</code>时候，传进去的<code>self._handle_connection</code>，它的代码在<code>TCPServer</code>中，核心的功能代码内容是  </p>
<div class="highlight"><pre><span class="k">try</span><span class="p">:</span>  
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ssl_options</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>  
        <span class="n">stream</span> <span class="o">=</span> <span class="n">SSLIOStream</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">io_loop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="p">,</span>  
                <span class="n">max_buffer_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_buffer_size</span><span class="p">,</span>  
                <span class="n">read_chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_chunk_size</span><span class="p">)</span>  
    <span class="k">else</span><span class="p">:</span>  
        <span class="n">stream</span> <span class="o">=</span> <span class="n">IOStream</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">io_loop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="p">,</span>  
                <span class="n">max_buffer_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_buffer_size</span><span class="p">,</span>  
                <span class="n">read_chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">read_chunk_size</span><span class="p">)</span>  
    <span class="n">future</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">handle_stream</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>  
    <span class="k">if</span> <span class="n">future</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>  
        <span class="bp">self</span><span class="o">.</span><span class="n">io_loop</span><span class="o">.</span><span class="n">add_future</span><span class="p">(</span><span class="n">future</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">result</span><span class="p">())</span>  
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>  
        <span class="n">app_log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s">&quot;Error in connection callback&quot;</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>

<p>为每个connection创建<code>IOStream</code>实例（用于对socket的异步读写），之后的IO操作由此实例负责（其实在IOStream中的读写事件也会注册到ioloop中，后续分析）。然后调用<code>self.handle_stream(stream, address)</code>，<code>handle_stream()</code>由HTTPServer覆写：  </p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">handle_stream</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>  
    <span class="n">context</span> <span class="o">=</span> <span class="n">_HTTPRequestContext</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span>  
                        <span class="bp">self</span><span class="o">.</span><span class="n">protocol</span><span class="p">)</span>  
    <span class="n">conn</span> <span class="o">=</span> <span class="n">HTTP1ServerConnection</span><span class="p">(</span>  
            <span class="n">stream</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conn_params</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>  
    <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>  
    <span class="n">conn</span><span class="o">.</span><span class="n">start_serving</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

<p><code>handler_stream</code>创建了HTTPConnection对象，HTTPConnection对象负责处理剩下的交互部分  </p>

<p>ok，HTTPServer大体的核心流程走完了一遍  </p>

<h3>三. 后续</h3>

<p>现在，所有的socket（listen和client）都被注册进了ioloop，它们会被不断地轮询检查，是否有io事件发生。如有读写事件发生，会通过iostream封装的异步READ和WRITE函数进行。HTTPConnection，IOLOOP和IOSTERAM后续再进行分析  </p>

<hr/>

<p>本文参考：<a href="http://www.douban.com/group/topic/13276435/">mywaiting.douban</a>; <a href="kenby.iteye.com/blog/1159621">kenby.iteye</a></p>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[Unix五种I/O模型对比]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/linux-five-io-models/"/>
        <updated>2015-11-04T19:30:00Z</updated>
        <published>2015-11-04T19:30:00Z</published>
        <id>http://sukai.me/linux-five-io-models/</id>
        <content type="html">
            <![CDATA[
             <h3>一. 总览</h3>

<p>先来说一下，<strong>Unix平台有哪几种I/O模型：</strong>  </p>

<ul>
<li>阻塞I/O（blocking I/O）<br/></li>
<li>非阻塞I/O（nonblocking I/O）<br/></li>
<li>I/O多路复用（I/O multiplexing），如select, poll<br/></li>
<li>信号驱动I/O（signal driven I/O），SIGIO<br/></li>
<li>异步I/O（asynchronous I/O），aio POSIX<br/></li>
</ul>

<p>备注：下面介绍各个I/O模型时，会配上一幅示意图，内容是进程进行读取数据操作的请求过程  </p>

<p>需要说明的是，请求进程读取数据的操作时分两步完成的：  </p>

<p>1.等待数据通过网络传输，到达本机内核数据区<br/>
2.将内核数据区的数据拷贝至用户数据区  </p>

<p>之后，程序即可对用户数据区的数据进行业务逻辑操作  </p>

<p>好了，开始了  </p>

<h3>二. 5种I/O模型</h3>

<h4>2.1 blocking I/O</h4>

<p>这个不用多说，最常见的模型。不人为重新设置，socket io默认都是阻塞模式  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/blocking-io.gif" alt="blocking-io"/>  </p>

<p>进程调用了recvfrom，系统不会立即返回，直到数据到达，并成功拷贝至用户区（或者发生一个错误）。之后进程才重新从阻塞状态进入就绪状态  </p>

<h4>2.2 nonblocking I/O</h4>

<p>设置socket为非阻塞模式后，如果I/O操作没有完成，内核不会让该进程进入睡眠状态（即阻塞），而是一直返回一个错误信号（e.g EWOULDBLOCK）  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/nonblocking-io.gif" alt="nonblocking-io"/>  </p>

<p>图片中前三次的recvfrom调用，数据都没有成功返回，而是返回EWOULDBLOCK错误。第四次调用时，数据才准备好。之后，数据被拷贝进用户区，recvfrom调用返回ok  </p>

<p>这种模型的缺点是：应用进程要不断地轮询（polling）内核，查看数据是否到达；这会一直占据CPU，造成浪费  </p>

<p>这种模型不是很常用  </p>

<h4>2.3 I/O multiplexing</h4>

<p>常见的io多路复用的系统调用有select或poll两种  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/io-multiplexing.gif" alt="io-multiplexing"/>  </p>

<p>如图所示：这种模型并没有阻塞在读取I/O操作的系统调用上（e.g recvfrom），而是阻塞在了select(poll)上。等到数据到来，select调用返回，应用程序调用recvfrom将数据从内核区拷贝至用户区进行操作  </p>

<p>仔细看实例图，发现select模型似乎有些disadvantage，即前后进行了两次系统调用，比上一个模型多了一次  </p>

<p>然而，select模型也有其明显的优势：每次select阻塞结束返回后，可以获得多个准备就绪的套接字（即一个select可以对多个套接字进行管理，类似于同时多个监控套接字上的事件是否就绪）  </p>

<p>PS：还有一种与该模型类似的I/O模型：多线程模型。一个线程对应一个套接字，一个线程的阻塞，不影响其他应用  </p>

<h4>2.4 Signal-Driven I/O</h4>

<p>当描述符就绪时，我们可以让内核使用SIGIO信号通知应用程序  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/signal-io.gif" alt=""/>  </p>

<p>首先，我们先得建立一个信号处理者（signal handler），之后程序继续运行干别的事情（此时，并不会阻塞），同时一边等待数据的到达。当数据到达，signal信号激发，之后应用程序可以进行内核区到用户区的数据拷贝（此时是阻塞的），随后进行处理  </p>

<p>该模型的好处就是，等待数据到达前，当前应用线程不会被阻塞  </p>

<h4>2.5 Asynchronous I/O</h4>

<p>AIO是由POSIX标准定义的。它的工作方式是：当所有的I/O操作完成后（包括将数据从内核区复制到用户区），内核再通知应用程序  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/aio.gif" alt="aio"/>  </p>

<p>和signal-driven io不同的是，信号驱动式模型是在数据拷贝前通知应用程序的，这是还未开始真正的I/O操作；而aio是在I/O操作完成时候再进行通知  </p>

<h3>三. 五种I/O模型的比较</h3>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/difference-ios.gif" alt="differnence-between-ios"/>  </p>

<h4>补充：同步I/O和异步I/O</h4>

<ul>
<li>同步I/O：在I/O操作未完成前，请求进程会被阻塞<br/></li>
<li>异步I/O：在I/O操作未完成前，请求进程未会被阻塞<br/></li>
</ul>

<p>上述五种I/O模型，前四种均属于同步I/O，因为recvfrom调用均阻塞了当前请求进程。只有最后一种io属于异步I/O  </p>

<p>我认为，同步与异步的区别在于，数据拷贝时进程是否阻塞；阻塞于非阻塞的区别在于应用程序的调用内核是否立即返回  </p>

<h3>四. 再谈I/O多路复用</h3>

<p>常见的I/O多路复用技术有：  </p>

<ul>
<li>select<br/></li>
<li>poll<br/></li>
</ul>

<p>还有一个高级版本的，叫epoll  </p>

<h4>4.1 select</h4>

<p>select()，确定一个或多个套接口的状态，本函数用于确定一个或多个套接口的状态，对每一个套接口，调用者可查询它的可读性、可写性及错误状态信息，用fd_set结构来表示一组等待检查的套接口，在调用返回时，这个结构存有满足一定条件的套接口组的子集，并且select()返回满足条件的套接口的数目  </p>

<p>其缺点：  </p>

<ul>
<li>每次调用select，先要把fd集合从用户态拷贝到内核态<br/></li>
<li>同时每次调用select都需要在内核遍历传递进来的所有fd；即：每次都会无差别的轮询，即要遍历所有的文件描述符；IO效率随着FD数目增加而线性下降<br/></li>
<li>select所能支持的最多文件描述符数量默认是1024，不是很多<br/></li>
</ul>

<p>Java版本一的NIO库就是利用的select模型，可以参阅我之前的一篇博客<a href="http://sukai.me/java-NIO%E5%88%9D%E6%8E%A2/">“Java NIO初探”</a>  </p>

<h4>4.2 poll</h4>

<p>和select类似  </p>

<p>不同之处在于，描述fd集合的方式不同，poll使用pollfd结构，而不是select的fd_set结构  </p>

<h4>4.3 epoll</h4>

<p>epoll算是I/O多路复用的高级版本，对前两者做了一些改进  </p>

<p>对于第一个缺点，epoll的解决方案在epoll_ctl函数中。每次注册新的事件到epoll句柄中时（在epoll_ctl中指定EPOLL_CTL_ADD），会把所有的fd拷贝进内核，而不是在epoll_wait的时候重复拷贝。epoll保证了每个fd在整个过程中只会拷贝一次。  </p>

<p>对于第二个缺点，epoll的解决方案不像select或poll一样每次都把current轮流加入fd对应的设备等待队列中，而只在epoll_ctl时把current挂一遍（这一遍必不可少）并为每个fd指定一个回调函数，当设备就绪，唤醒等待队列上的等待者时，就会调用这个回调函数，而这个回调函数会把就绪的fd加入一个就绪链表）。epoll_wait的工作实际上就是在这个就绪链表中查看有没有就绪的fd（利用schedule_timeout()实现睡一会，判断一会的效果，和select实现中的第7步是类似的）。  </p>

<p>对于第三个缺点，epoll没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048  </p>

<p>epoll的优点主要是一下几个方面：  </p>

<ul>
<li>IO的效率不会随着监视fd的数量的增长而下降<br/></li>
<li>监视的描述符数量不受限制<br/></li>
</ul>

<p>关于epoll，可以再看看<a href="http://blog.csdn.net/lingfengtengfei/article/details/12398299">CSDN的帖子</a>  </p>

<h4>4.4 比较</h4>

<p>在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一 个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知  </p>

<p>这方面的比较，也有一份好帖子，<a href="http://www.cnblogs.com/Anker/p/3265058.html">cnblog</a>  </p>

<hr/>

<p>本文匆忙赶成，错误很多，欢迎纠错  </p>

<p>本文翻译自：<a href="http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/ch06lev1sec2.html">unix_network_programming</a>  </p>

<hr/>

<h3>参考来源</h3>

<ul>
<li><a href="http://blog.csdn.net/shallwake/article/details/5265287">CSDN</a><br/></li>
<li><a href="http://www.cnblogs.com/Anker/p/3265058.html">cnBlog</a></li>
</ul>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[多说评论迁移]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/doushuo-commment/"/>
        <updated>2015-10-02T15:50:00Z</updated>
        <published>2015-10-02T15:50:00Z</published>
        <id>http://sukai.me/doushuo-commment/</id>
        <content type="html">
            <![CDATA[
             <p>国庆了，放假了，学校人烟稀少  </p>

<p>博客搭建也已经一年多了。之前的博客域名kaiyao.net.cn由于是中国域名，需要备案，也不方便别人记住，就换了一个更个性化的域名：sukai.me，之后就准备一直用这个了。虽然.me域名要贵很多，但算是给自己投资吧，希望我能坚持写博客  </p>

<p>博客迁移，是一件挺麻烦的事情，涉及到文章数据和评论数据。我的博客平台使用的多说评论系统，在我迁移评论的时候，也遇到了一些障碍。但是，最终还是比较完美地迁移成功。讲一下我迁移的方案吧  </p>

<h3>多说评论迁移准备工作</h3>

<p>先去多说后台管理系统，寻找迁移方法。果然，在工具里面找到了<strong>导入数据，导出数据</strong>功能，然后选择<strong>包含评论数据</strong>，并导出评论。之后，会得到一个Json格式的文件  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/多说导入导出数据.png" width = "380" height = "260" alt="多说导入导出数据" align=center />  </p>

<p>导出的json文件没有格式化，随便找个json在线格式化网站，格式化一下，来看看里面是什么内容。我们来选其中一个个体看一下  </p>

<p><img src="http://7xl2fd.com1.z0.glb.clouddn.com/duoshuo-json.png" width = "380" height = "260" alt="json个体" align=center />  </p>

<p>不难读懂：post_id就是这条评论的全局唯一的标识，thread_id是评论所在网页的全局唯一标识（即文章的id），message即具体评论的内容，下面的author_id，author_emial等等就是评论人的相关多说账号信息了  </p>

<p><a href="http://dev.duoshuo.com/docs/500d0629448f04782b00000a">多说文档</a>也是说的明明白白的，结合看一下，一目了然  </p>

<p>ok，当时，心中就大体有方案了  </p>

<h3>多说评论迁移方案</h3>

<p>既然是迁移评论，那么该评论的全局id肯定还是原来的，变的就是文章id了。因为换了新域名嘛，文章id变换了，只要把json文件里面评论的原文章id（就是thread_id）变成相应的新文章id就行啦  </p>

<p>那么，怎么获取新文章的thread_id呢。我当时想到的最笨的方法，去新文章页面下面随便评论一下，从新域名的多说后台系统导出评论数据，打开看一下，thread_id不全都有了吗  </p>

<p>所以，具体的方案就是：从old.com（老域名）的多说后台系统导出评论数据，找到old.com/first-post文章的thread_id；在对应的新文章new.com/first-post下随便评论，导出评论数据，获得新的thread_id；用新id覆盖老id；最后在新域名的博客多说后台系统导入json评论数据就ok了  </p>

<p>亲测可行的  </p>

<p>至于，你想手动覆盖json文件里面的old thread_id，还是写脚本对josn文件操作进行覆盖，看你评论数量而定吧。怎么省事，怎么搞  </p>

<h3>对多说的吐槽</h3>

<p>寻找评论迁移方案的时候，先在多说开发者中心尝试看看能不能找到，结果是没找到。而且，我觉的多说是不是没人维护了？？？很多人在下面提问，就是没有技术支持的回答  </p>

<p>还有，在多说后台管理系统的文章管理页面，多说永远只呈现给我一页的文章数据，甚至有很多内网测试的文章在上面，什么127.0.0.1:8080/first-post这一类。想翻看第二页更多的文章，根本做不到，只有删除第一页文章才行  </p>

<p>我还想换一个评论系统disqus，由于它的加载比较慢，账号不支持国内许多社交账号，还是放弃了  </p>

<p>不得不说，多说成功的原因就是：接天朝地气吧。界面做的也比disqus好看些。接地气，而且好看的东西果然还是很受欢迎的。  </p>

<p>多数的后台数据管理，我就不敢恭维了。估计不止我一个人在吐槽吧  </p>

<p>放假在实验室，没事就喜欢瞎折腾，不写了，国庆快乐啦！</p>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[利用大脑进行主动式学习]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/brain_storming/"/>
        <updated>2015-06-08T12:40:00Z</updated>
        <published>2015-06-08T12:40:00Z</published>
        <id>http://sukai.me/brain_storming/</id>
        <content type="html">
            <![CDATA[
             <p>最近读完了<a href="http://book.douban.com/subject/5372651/">《程序员的思维修炼》</a>，有关认知科学，学习和行为理论的头脑风暴一直充斥我的大脑，与其产生共鸣的同时，很想把书中提出的观点和技巧牢记下来  </p>

<p>在读《程序员思维修炼》的期间，脑子里竟不由主地回忆了一些<a href="http://book.douban.com/subject/25783654/">《如何高效学习》</a>里面的内容，后来翻看其笔记，发现二者本质有许多共同之处的，到目前，两本书的内容一直很混乱地存储在我的脑子里，自己大脑着实不发达，需要好好将这些整理下来  </p>

<h3>《程序员的思维修炼》大体内容</h3>

<p>该书从一个模型出发，即Dreyfus模型，介绍了每个学习领域，从新手到专家必须经历的5个阶段：  </p>

<p>新手，高级新手，胜任者，精通者，专家  </p>

<p>该模型强调新手只会执行命令，而专家，凭直觉工作，而且能出色表现。看了第三章，就知道了，这个所谓的直觉就是我们右半脑的功劳  </p>

<p>书中，大脑被类比为计算机，左右半脑分别对应1，2号CPU，即L型和R型。L型负责线性任务指令，逻辑思维和语言处理等细节任务；R型则是一个搜索引擎，能在你思考时候，搜索你所有的存储记忆，并异步返回结果集。一句话总结下：L型负责细节，R型负责整体  </p>

<p>可想而知，R型对于创造力非常重要，这是区别专家和菜鸟的界限  </p>

<p>但是，L型和R型存在着竞争，因为它们共享一根总线，通向大脑内存，大多数人都是L型在工作，R型的作用没有真正发挥出来，你需要主动地去挖掘R型能力  </p>

<p>所以，本书就针对如何充分利用好R型，在后几章提出了许多实用的技巧：  </p>

<ul>
<li>利用右脑，学会R型到L型的转换<br/></li>
<li>调试大脑，消除思维定势等<br/></li>
<li>学会主动学习，指定SMART计划，学会SQ3R主动阅读法<br/></li>
<li>在实践中积累经验<br/></li>
<li>如何控制好中断，保证工作中的注意力<br/></li>
</ul>

<h3>《程序员的思维修炼》和《如何高效学习》的联系</h3>

<p>翻看了高效学习的读书笔记，发现高效学习的学习技巧大多就是针对如何挖掘R型而提出的，比如：通过笔记流（图像流）主动地获取对知识的宏观把握；学会给知识创建模型和结构；学会在不同知识之间建立主动的联系。这些我感觉，都是在讲一个道理：宏观把握，宏观把握，建立联系，建立联系！  </p>

<p>比如关于读书，很简单的改进方法，读之前，先扫一边目录，记下问题，然后有了宏观上的大体了解，进行全部阅读（SQ3R主动阅读法）  </p>

<h3>如何利用右脑</h3>

<p>方法说起来真的很简单：听音乐，绘画，静思，慢跑，针线活，攀岩，散步，尝试新鲜事物等等，即给大脑分配一个会被L型拒绝的工作，从而激活R型的活动  </p>

<p>这里有个“笑话”：传闻，爱因斯坦打盹的时候，手里会握着几个滚珠，刚要睡着的时候，滚珠会掉落，会吵醒爱因斯坦，然后爱因斯坦便会立马拿起笔纸，记录一些东西。因为，他觉得刚睡着，大脑一定在做梦，此时，记忆回顾活动很频繁，一定会产生很多好想法  </p>

<p>每个人都有好想法，只是大多数人想了也就想了，没有充分利用，从中获益。成功的人或许24小时拿着可以记录的东西，不漏记任何一个想法  </p>

<h3>实战性的技巧</h3>

<p>整理一下，值得借鉴的主动学习技巧  </p>

<ul>
<li>制定SMART目标<br/></li>
<li>制定务实的投资计划，包括定期投资和主动投资<br/></li>
<li>多感官学习模式，视觉，听觉，动觉<br/></li>
<li>SQ3R主动阅读法<br/></li>
<li>思维导图笔记<br/></li>
<li>以教代学，对着静物讲述自己刚刚所学知识<br/></li>
</ul>

<p>还有针对注意力的技巧  </p>

<ul>
<li>冥想<br/></li>
<li>在电脑工作时，使用虚拟桌面，从而保存情境堆栈，防止中断回来，很难进入状态<br/></li>
<li>时刻记录自己的想法<br/></li>
</ul>

<p>说到注意力，值得看的一本书还有《番茄工作法》，虽然，我觉得番茄工作法很麻烦。但是，在你没有大幅度改善你的拖延症和不集中注意力之前，还是值得去试  </p>

<p>突然，又想起一本书，当时在豆瓣上买的电子书，叫做<a href="http://book.douban.com/subject/20389192/">《30岁前的每一天》</a>，该书也讲解了运用记事本，如何改善注意力&hellip;&hellip;不过，内容和其余书好像啊，有没有抄袭和借鉴别的书啊&hellip;&hellip;  </p>

<hr/>

<p>PS：附上我的读书笔记  </p>

<ul>
<li><a href="https://github.com/LeanCodeTeam/Xmind_Reading_Note/blob/sukai/gas_station/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E6%80%9D%E7%BB%B4%E4%BF%AE%E7%82%BC.xmind">《程序员的思维修炼》思维导图笔记</a><br/></li>
<li><a href="https://github.com/su-kaiyao/record/tree/master/Books/GasStation/%E3%80%8A%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E3%80%8B">《如何高效学习》markdown笔记</a><br/></li>
</ul>

<p>给大伙推荐这两本书，不读别后悔  </p>

            ]]>
        </content>
    </entry>
    
    <entry>
        <title><![CDATA[Docker初探]]></title>
        <author><name>SuKai</name><uri>http://sukai.me/</uri></author>
        <link href="http://sukai.me/docker-explore/"/>
        <updated>2015-06-03T21:50:00Z</updated>
        <published>2015-06-03T21:50:00Z</published>
        <id>http://sukai.me/docker-explore/</id>
        <content type="html">
            <![CDATA[
             <p>从周一到今天周三，花了三天的课余时间，看完了一本《第一本Docker书》。对Docker，应该算是有入门级的了解了  </p>

<p>PS：当时，我在学校图书馆搜索该书的时候，状态是“正在上架”；学校还是蛮紧跟潮流的，这么火的容器技术书籍，学校选购了，赞。后来，足足瞄了一个星期，书一上架，我就从图书馆借回来了，还捎带了旁边的另一本《Docker技术入门》  </p>

<p>关于该书，我的思维导图笔记地址在<a href="https://github.com/su-kaiyao/gold/tree/master/docker" target="_blank">我的gold仓库中</a>  </p>

<p>思维导图笔记转为png如下：  </p>

<p><img src="https://raw.githubusercontent.com/su-kaiyao/gold/master/docker/%E7%AC%AC%E4%B8%80%E6%9C%ACDocker%E4%B9%A6.png" alt="第一本Docker书"/>  </p>

<p>具体内容就不再重复，可以直接翻阅思维导图比较  </p>

<p>希望自己日后能把docker用到项目中去</p>

            ]]>
        </content>
    </entry>
    
</feed>